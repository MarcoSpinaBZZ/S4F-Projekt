/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/tetris/page"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Cmelon%5CS4F-Projekt%5Cpages%5Ctetris%5Cpage.jsx&page=%2Ftetris%2Fpage!":
/*!*****************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Cmelon%5CS4F-Projekt%5Cpages%5Ctetris%5Cpage.jsx&page=%2Ftetris%2Fpage! ***!
  \*****************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/tetris/page\",\n      function () {\n        return __webpack_require__(/*! ./pages/tetris/page.jsx */ \"./pages/tetris/page.jsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/tetris/page\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1DJTNBJTVDVXNlcnMlNUNtZWxvbiU1Q1M0Ri1Qcm9qZWt0JTVDcGFnZXMlNUN0ZXRyaXMlNUNwYWdlLmpzeCZwYWdlPSUyRnRldHJpcyUyRnBhZ2UhLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsd0RBQXlCO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz83YzVlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvdGV0cmlzL3BhZ2VcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3BhZ2VzL3RldHJpcy9wYWdlLmpzeFwiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuX19ORVhUX1AucHVzaChbXCIvdGV0cmlzL3BhZ2VcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Cmelon%5CS4F-Projekt%5Cpages%5Ctetris%5Cpage.jsx&page=%2Ftetris%2Fpage!\n"));

/***/ }),

/***/ "./pages/tetris/page.jsx":
/*!*******************************!*\
  !*** ./pages/tetris/page.jsx ***!
  \*******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("//  TODO:\n//    * touch controls\n//    * allow late piece rotation\n//    * code cleanup\n//--------------------------------------------------//\n//    PAGE OBJECT & LOGIC                           //\n//--------------------------------------------------//\nvar Page = {\n    IsSetup: false,\n    body: document.getElementsByTagName(\"body\")[0],\n    cvs: document.createElement(\"canvas\"),\n    ctx: 0,\n    unitSize: 0,\n    AreaArr: [],\n    // calculates the unit size, canvas bounds, and canvas positioning\n    WindowChanged: function() {\n        // Calulcate the unitSize based on window width and height.\n        // The minimum of these calculations will be used.\n        var bodyW = document.documentElement.clientWidth, bodyH = document.documentElement.clientHeight, newUnitW = (bodyW - bodyW % 80) / 16, newUnitH = (bodyH - bodyH % 100) / 20, newUnitMin = Math.max(Math.min(newUnitW, newUnitH), 20);\n        // if the calcUnitMin != unitSize, update unitSize, recalculate\n        // all DrawAreaObjs, and update the canvas element bounds\n        this.unitSize = newUnitMin;\n        // store Right-most & Bottom-most points for canvas bounds\n        var rightLimit = 0, bottomLimit = 0;\n        for(var i = 0; i < Page.AreaArr.length; i++){\n            Page.AreaArr[i].CalculateBounds();\n            var newRightLimit = Page.AreaArr[i].left + Page.AreaArr[i].W, newBottomLimit = Page.AreaArr[i].top + Page.AreaArr[i].H;\n            rightLimit = Math.max(newRightLimit, rightLimit);\n            bottomLimit = Math.max(newBottomLimit, bottomLimit);\n        }\n        this.cvs.width = rightLimit;\n        this.cvs.height = bottomLimit;\n        // left pos uses Game.W because ideally that area is centered\n        var topPos = (bodyH - bottomLimit) / 2, leftPos = bodyW / 2 - this.Game.W / 2, rightOffset = bodyW - (leftPos + rightLimit) - this.unitSize * 0.5;\n        // if default canvas positioning extends beyond screen, adjust it\n        if (rightOffset < 0) {\n            leftPos = Math.max(this.unitSize * 0.5, leftPos + rightOffset);\n        }\n        this.cvs.style.left = leftPos + \"px\";\n        this.cvs.style.top = topPos + \"px\";\n    },\n    // performs the page setup\n    Initialize: function() {\n        // if page has not been setup, do initial setup\n        if (this.IsSetup === false) {\n            document.body.appendChild(Page.cvs);\n            this.body.style.overflow = \"hidden\";\n            this.body.style.backgroundColor = \"rgb(19,21,25)\";\n            this.cvs.style.position = \"absolute\";\n            this.ctx = this.cvs.getContext(\"2d\");\n            this.IsSetup = true;\n        }\n        this.WindowChanged();\n        // dirty all draw areas\n        for(var i = 0; i < Page.AreaArr.length; i++){\n            Page.AreaArr[i].IsDirty = true;\n        }\n    },\n    // redraws canvas visuals whenever the page is marked as dirty\n    Update: function() {\n        for(var i = 0; i < Page.AreaArr.length; i++){\n            if (Page.AreaArr[i].IsDirty) {\n                Page.AreaArr[i].Draw();\n                Page.AreaArr[i].IsDirty = false;\n            }\n        }\n    }\n};\n// Definition for Area objects. Bounds are in UNITS\nfunction DrawAreaObj(Left, Top, Width, Height, DrawFunction) {\n    // bounds in UNITS\n    this.leftBase = Left;\n    this.topBase = Top;\n    this.widthBase = Width;\n    this.heightBase = Height;\n    // bounds in PIXELS\n    this.left = 0;\n    this.top = 0;\n    this.W = 0;\n    this.H = 0;\n    // dirty flag (clean yourself up flag, you're better than that)\n    this.IsDirty = false;\n    // bounds recalculated and area dirtied when unitSize changes\n    this.CalculateBounds = function() {\n        this.left = this.leftBase * Page.unitSize;\n        this.top = this.topBase * Page.unitSize;\n        this.W = this.widthBase * Page.unitSize;\n        this.H = this.heightBase * Page.unitSize;\n        this.IsDirty = true;\n    };\n    // draw function as passed in by the callee\n    this.Draw = DrawFunction;\n    // push this area into the area arr    \n    Page.AreaArr.push(this);\n}\n_c = DrawAreaObj;\nPage.Game = new DrawAreaObj(0, 0, 10, 20, function() {\n    // unitSize minus a couple pixels of separation\n    var uDrawSize = Page.unitSize - 2, drawL, drawT;\n    // redraws the background elements for game area\n    Page.ctx.fillStyle = \"rgb(28,30,34)\";\n    Page.ctx.fillRect(this.left, this.top, this.W, this.H);\n    // draw the static unit blocks\n    for(var i = 0; i < GM.StaticUnits.length; i++){\n        for(var j = 0; j < GM.StaticUnits[i].length; j++){\n            // get the unit value for this index pair\n            var uValue = GM.StaticUnits[i][j];\n            // if this unit value is not 0, draw the unit\n            if (uValue !== 0) {\n                drawL = i * Page.unitSize + 1;\n                drawT = j * Page.unitSize + 1;\n                // fill this square with color based on player alive status        \n                Page.ctx.fillStyle = GM.IsAlive ? uValue : \"rgb(34,36,42)\";\n                Page.ctx.fillRect(drawL, drawT, uDrawSize, uDrawSize);\n            }\n        }\n    }\n    // draw the current active projection and piece (if exists)\n    if (GM.Pc.Cur !== 0 && GM.IsAlive) {\n        var projColor = ColorWithAlpha(GM.Pc.Cur.color, 0.1);\n        for(var k = 0; k < GM.Pc.Cur.UO.arr.length; k++){\n            drawL = (GM.Pc.Cur.x + GM.Pc.Cur.UO.arr[k].x) * Page.unitSize + 1;\n            drawT = (GM.Pc.Cur.y + GM.Pc.Cur.UO.arr[k].y) * Page.unitSize + 1;\n            Page.ctx.fillStyle = GM.Pc.Cur.color;\n            Page.ctx.fillRect(drawL, drawT, uDrawSize, uDrawSize);\n            // also draw the projection (if one exists)\n            if (GM.IsAlive && GM.Pc.ProjY !== 0) {\n                drawT += GM.Pc.ProjY * Page.unitSize;\n                Page.ctx.fillStyle = projColor;\n                Page.ctx.fillRect(drawL, drawT, uDrawSize, uDrawSize);\n            }\n        }\n    }\n    // if the player is dead, draw the game over text\n    if (!GM.IsAlive) {\n        DrawText(\"GAME OVER\", \"rgb(255,255,255)\", \"500\", \"center\", uDrawSize, this.W / 2, this.H / 4);\n    }\n});\nPage.UpcomingA = new DrawAreaObj(10.5, 2.6, 2.5, 2.5, function() {\n    var uDrawSize = Math.floor(Page.unitSize / 2), pcA = GM.Pc.Upcoming[0];\n    // next box background\n    Page.ctx.fillStyle = \"rgb(28,30,34)\";\n    Page.ctx.fillRect(this.left, this.top, this.W, this.H);\n    // draw the upcoming piece (if one exists)\n    if (pcA !== 0) {\n        Page.ctx.fillStyle = pcA.color;\n        var totalL = 0, totalT = 0, countedL = [], countedT = [];\n        // calculate average positions of units in order to center\n        for(var i = 0; i < pcA.UO.arr.length; i++){\n            var curX = pcA.UO.arr[i].x, curY = pcA.UO.arr[i].y;\n            if (countedL.indexOf(curX) < 0) {\n                countedL.push(curX);\n                totalL += curX;\n            }\n            if (countedT.indexOf(curY) < 0) {\n                countedT.push(curY);\n                totalT += curY;\n            }\n        }\n        var avgL = uDrawSize * (totalL / countedL.length + 0.5), avgT = uDrawSize * (totalT / countedT.length + 0.5), offsetL = this.left + this.W / 2, offsetT = this.top + this.H / 2;\n        console.log(avgL + \", \" + avgT);\n        // now draw the upcoming piece, using avg vars to center\n        for(var j = 0; j < pcA.UO.arr.length; j++){\n            var drawL = Math.floor(offsetL - avgL + pcA.UO.arr[j].x * uDrawSize), drawT = Math.floor(offsetT - avgT + pcA.UO.arr[j].y * uDrawSize);\n            Page.ctx.fillRect(drawL, drawT, uDrawSize - 1, uDrawSize - 1);\n        }\n    }\n});\nPage.UpcomingB = new DrawAreaObj(10.5, 5.2, 2.5, 2.5, function() {\n    var uDrawSize = Math.floor(Page.unitSize / 2), pcB = GM.Pc.Upcoming[1];\n    // next box background\n    Page.ctx.fillStyle = \"rgb(28,30,34)\";\n    Page.ctx.fillRect(this.left, this.top, this.W, this.H);\n    // draw the upcoming piece (if one exists)\n    if (pcB !== 0) {\n        Page.ctx.fillStyle = pcB.color;\n        var totalL = 0, totalT = 0, countedL = [], countedT = [];\n        // calculate average positions of units in order to center\n        for(var i = 0; i < pcB.UO.arr.length; i++){\n            var curX = pcB.UO.arr[i].x, curY = pcB.UO.arr[i].y;\n            if (countedL.indexOf(curX) < 0) {\n                countedL.push(curX);\n                totalL += curX;\n            }\n            if (countedT.indexOf(curY) < 0) {\n                countedT.push(curY);\n                totalT += curY;\n            }\n        }\n        var avgL = uDrawSize * (totalL / countedL.length + 0.5), avgT = uDrawSize * (totalT / countedT.length + 0.5), offsetL = this.left + this.W / 2, offsetT = this.top + this.H / 2;\n        console.log(avgL + \", \" + avgT);\n        // now draw the upcoming piece, using avg vars to center\n        for(var j = 0; j < pcB.UO.arr.length; j++){\n            var drawL = Math.floor(offsetL - avgL + pcB.UO.arr[j].x * uDrawSize), drawT = Math.floor(offsetT - avgT + pcB.UO.arr[j].y * uDrawSize);\n            Page.ctx.fillRect(drawL, drawT, uDrawSize - 1, uDrawSize - 1);\n        }\n    }\n});\nPage.UpcomingC = new DrawAreaObj(10.5, 7.8, 2.5, 2.5, function() {\n    var uDrawSize = Math.floor(Page.unitSize / 2), pcC = GM.Pc.Upcoming[2];\n    // next box background\n    Page.ctx.fillStyle = \"rgb(28,30,34)\";\n    Page.ctx.fillRect(this.left, this.top, this.W, this.H);\n    // draw the upcoming piece (if one exists)\n    if (pcC !== 0) {\n        Page.ctx.fillStyle = pcC.color;\n        var totalL = 0, totalT = 0, countedL = [], countedT = [];\n        // calculate average positions of units in order to center\n        for(var i = 0; i < pcC.UO.arr.length; i++){\n            var curX = pcC.UO.arr[i].x, curY = pcC.UO.arr[i].y;\n            if (countedL.indexOf(curX) < 0) {\n                countedL.push(curX);\n                totalL += curX;\n            }\n            if (countedT.indexOf(curY) < 0) {\n                countedT.push(curY);\n                totalT += curY;\n            }\n        }\n        var avgL = uDrawSize * (totalL / countedL.length + 0.5), avgT = uDrawSize * (totalT / countedT.length + 0.5), offsetL = this.left + this.W / 2, offsetT = this.top + this.H / 2;\n        console.log(avgL + \", \" + avgT);\n        // now draw the upcoming piece, using avg vars to center\n        for(var j = 0; j < pcC.UO.arr.length; j++){\n            var drawL = Math.floor(offsetL - avgL + pcC.UO.arr[j].x * uDrawSize), drawT = Math.floor(offsetT - avgT + pcC.UO.arr[j].y * uDrawSize);\n            Page.ctx.fillRect(drawL, drawT, uDrawSize - 1, uDrawSize - 1);\n        }\n    }\n});\nPage.ScoreBarHigh = new DrawAreaObj(10.5, 0, 4.5, 1, function() {\n    // draw the score area back bar\n    Page.ctx.fillStyle = \"rgb(28,30,34)\";\n    Page.ctx.fillRect(this.left, this.top, this.W, this.H);\n    // Draw the trophy symbol\n    var miniUnit, left, top, width, height;\n    miniUnit = Page.unitSize * 0.01;\n    Page.ctx.fillStyle = \"rgb(255,232,96)\";\n    // trophy base\n    left = Math.floor(this.left + miniUnit * 33);\n    top = Math.floor(this.top + this.H - miniUnit * 28);\n    width = Math.floor(miniUnit * 30);\n    height = Math.floor(miniUnit * 12);\n    Page.ctx.fillRect(left, top, width, height);\n    // trophy trunk\n    left = Math.floor(this.left + miniUnit * 42);\n    top = Math.floor(this.top + this.H - miniUnit * 50);\n    width = Math.floor(miniUnit * 12);\n    height = Math.floor(miniUnit * 32);\n    Page.ctx.fillRect(left, top, width, height);\n    // trophy bowl\n    left = Math.floor(this.left + miniUnit * 48);\n    top = Math.floor(this.top + this.H - miniUnit * 68);\n    Page.ctx.arc(left, top, miniUnit * 24, 0, Math.PI);\n    Page.ctx.fill();\n    // draw the player's current score\n    text = (\"00000000\" + GM.ScoreHigh).slice(-7);\n    left = this.left + this.W - 4;\n    top = this.top + Page.unitSize * 0.8;\n    size = Math.floor(Page.unitSize * 0.8) + 0.5;\n    DrawText(text, \"rgb(255,232,96)\", \"500\", \"right\", size, left, top);\n});\nPage.ScoreBarCur = new DrawAreaObj(10.5, 1.1, 4.5, 1, function() {\n    // draw the score area back bar\n    Page.ctx.fillStyle = \"rgb(28,30,34)\";\n    Page.ctx.fillRect(this.left, this.top, this.W, this.H);\n    // draw the player's current level\n    var text1, left, top, size1, miniUnit;\n    miniUnit = Page.unitSize * 0.01;\n    text1 = (\"00\" + GM.Level).slice(-2);\n    left = this.left + Math.floor(miniUnit * 50);\n    top = this.top + Page.unitSize * 0.8;\n    size1 = Math.floor(Page.unitSize * 0.5);\n    DrawText(text1, \"rgb(128,128,128)\", \"900\", \"center\", size1, left, top);\n    // draw the player's current score\n    text1 = (\"00000000\" + GM.ScoreCur).slice(-7);\n    left = this.left + this.W - 4;\n    top = this.top + Page.unitSize * 0.8;\n    size1 = Math.floor(Page.unitSize * 0.8) + 0.5;\n    DrawText(text1, \"rgb(255,255,255)\", \"500\", \"right\", size1, left, top);\n});\n//--------------------------------------------------//\n//    GAME MANAGER OBJECT & LOGIC                   //\n//--------------------------------------------------//\nvar GM = {\n    //-- VARS ---------*/\n    // timers\n    TimeCur: 0,\n    TimeEvent: 0,\n    TickRate: 0,\n    // player status & score\n    IsAlive: 0,\n    Level: 0,\n    PiecesRemaining: 0,\n    // score count and current piece score modifiers\n    ScoreHigh: 0,\n    ScoreCur: 0,\n    ScoreBonus: 0,\n    DifficultFlag: 0,\n    // array of grid squares\n    StaticUnits: [],\n    /*-- FCNS ---------*/ // Set up intial game var values\n    Initialize: function() {\n        // reset current piece vars\n        this.Pc.Next = this.Pc.Cur = this.Pc.ProjY = 0;\n        // populate the GM's static unit array with 0's (empty)\n        for(var i = 0; i < 10; i++){\n            this.StaticUnits[i] = [];\n            for(var j = 0; j < 20; j++){\n                this.StaticUnits[i][j] = 0;\n            }\n        }\n        // reset timer\n        this.TimeCur = this.TimeEvent = 0;\n        this.TickRate = 500;\n        // set up level values for level 1\n        this.PiecesRemaining = 10;\n        this.Level = 1;\n        // reset the score and set player to alive\n        this.ScoreCur = 0;\n        this.IsAlive = true;\n    },\n    // updates time each frame and executing logic if a tick has passed\n    Update: function() {\n        this.TimeCur = new Date().getTime();\n        if (this.TimeCur >= this.TimeEvent) {\n            if (GM.Pc.Cur === 0 && this.IsAlive) {\n                this.Pc.Generate();\n            } else {\n                this.Pc.DoGravity();\n                this.Pc.ProjY = this.Pc.TryProject();\n                Page.Game.IsDirty = true;\n            }\n            this.RefreshTimer();\n        }\n    },\n    // reset the tick timer (generates a new TimeEvent target)\n    RefreshTimer: function() {\n        this.TimeEvent = new Date().getTime() + this.TickRate;\n    },\n    // called when a piece is spawned, advances level if needed\n    PieceSpawned: function() {\n        this.PiecesRemaining--;\n        if (this.PiecesRemaining <= 0) {\n            this.AdvanceLevel();\n        }\n    },\n    // advance level, recalculate TickRate, reset pieces remaining\n    AdvanceLevel: function() {\n        this.Level++;\n        this.TickRate = Math.floor(555 * Math.exp(this.Level / -10));\n        this.PiecesRemaining = Math.floor(5000 / this.TickRate);\n        Page.ScoreBarCur.IsDirty = true;\n    },\n    // check specified rows to see if any can be cleared\n    CheckUnits: function(checkRowsRaw) {\n        var scoreMult = 0, pieceScore = 0, checkRows = [];\n        // add the scoreBonus for dropping\n        if (this.ScoreBonus > 0) {\n            pieceScore += this.ScoreBonus;\n        }\n        // sort the rows\n        for(var a = 0; a < 20; a++){\n            if (checkRowsRaw.indexOf(a) >= 0) {\n                checkRows.push(a);\n            }\n        }\n        for(var i = 0; i < checkRows.length; i++){\n            var hasGap = false, checkIndex = checkRows[i];\n            for(var j = 0; j < GM.StaticUnits.length; j++){\n                if (GM.StaticUnits[j][checkIndex] === 0) {\n                    hasGap = true;\n                    break;\n                }\n            }\n            if (hasGap === false) {\n                for(var k = 0; k < GM.StaticUnits.length; k++){\n                    GM.StaticUnits[k].splice(checkIndex, 1);\n                    GM.StaticUnits[k].unshift(0);\n                }\n                pieceScore += 100 + 200 * scoreMult;\n                if (scoreMult > 2) {\n                    pieceScore += 100;\n                }\n                scoreMult++;\n            }\n        }\n        if (this.DifficultFlag === 1) {\n            pieceScore = Math.floor(pieceScore * 1.5);\n            this.DifficultFlag = 0;\n        }\n        if (pieceScore > 0) {\n            this.ScoreCur += pieceScore;\n            Page.ScoreBarCur.IsDirty = true;\n            this.ScoreBonus = 0;\n            if (scoreMult > 3) {\n                this.DifficultFlag = 1;\n            }\n        }\n    },\n    GameOver: function() {\n        Page.Game.IsDirty = Page.ScoreBarCur.IsDirty = true;\n        if (this.ScoreCur > this.ScoreHigh) {\n            this.ScoreHigh = this.ScoreCur;\n            Page.ScoreBarHigh.IsDirty = true;\n            console.log(this.ScoreHigh);\n        }\n        this.IsAlive = false;\n    }\n};\n//--------------------------------------------------//\n//    PIECE OBJECT BUILDER                          //\n//--------------------------------------------------//\n// PcObj is used to create new piece object instances based on the\n// passed in parameters. PcObj is called by predefined templates\nGM.PcObj = function(color, rotCount, units) {\n    this.x = 5;\n    this.y = 0;\n    this.color = color;\n    this.UO = {};\n    // rotate this piece by advancing to next unit obj of linked list\n    this.Rotate = function() {\n        this.UO = this.UO.nextUO;\n    };\n    // set up the piece unit object linked list to define rotations\n    this.SetUO = function(rotCount, units) {\n        var linkedListUO = [];\n        linkedListUO[0] = {\n            nextUO: 0,\n            arr: []\n        };\n        linkedListUO[0].arr = units;\n        for(var i = 0; i < rotCount; i++){\n            var nextI = i + 1 < rotCount ? i + 1 : 0;\n            linkedListUO[i] = {\n                nextUO: 0,\n                arr: []\n            };\n            if (i > 0) {\n                linkedListUO[i - 1].nextUO = linkedListUO[i];\n            }\n            for(var j = 0; j < units.length; j++){\n                var unX, unY;\n                if (i === 0) {\n                    unX = units[j].x;\n                    unY = units[j].y;\n                } else {\n                    unX = linkedListUO[i - 1].arr[j].y * -1;\n                    unY = linkedListUO[i - 1].arr[j].x;\n                }\n                linkedListUO[i].arr[j] = {\n                    x: unX,\n                    y: unY\n                };\n            }\n        }\n        linkedListUO[rotCount - 1].nextUO = linkedListUO[0];\n        this.UO = linkedListUO[0];\n    };\n    this.SetUO(rotCount, units);\n};\n//--------------------------------------------------//\n//    PIECE TYPE TEMPLATES                          //\n//--------------------------------------------------//\n// Templates create a new piece object instance based on\n// their color, rotation count, and unit block definitions.\n// O - Square piece definition\nGM.O = function() {\n    return new GM.PcObj(\"rgb(255,232,51)\", 1, [\n        {\n            x: -1,\n            y: 0\n        },\n        {\n            x: 0,\n            y: 0\n        },\n        {\n            x: -1,\n            y: 1\n        },\n        {\n            x: 0,\n            y: 1\n        }\n    ]);\n};\n// I - Line piece definition\nGM.I = function() {\n    return new GM.PcObj(\"rgb(51,255,209)\", 2, [\n        {\n            x: -2,\n            y: 0\n        },\n        {\n            x: -1,\n            y: 0\n        },\n        {\n            x: 0,\n            y: 0\n        },\n        {\n            x: 1,\n            y: 0\n        }\n    ]);\n};\n// S - Right facing zigzag piece definition\nGM.S = function() {\n    return new GM.PcObj(\"rgb(106,255,51)\", 2, [\n        {\n            x: 0,\n            y: 0\n        },\n        {\n            x: 1,\n            y: 0\n        },\n        {\n            x: -1,\n            y: 1\n        },\n        {\n            x: 0,\n            y: 1\n        }\n    ]);\n};\n// Z - Left facing zigzag piece definition\nGM.Z = function() {\n    return new GM.PcObj(\"rgb(255,51,83)\", 2, [\n        {\n            x: -1,\n            y: 0\n        },\n        {\n            x: 0,\n            y: 0\n        },\n        {\n            x: 0,\n            y: 1\n        },\n        {\n            x: 1,\n            y: 1\n        }\n    ]);\n};\n// L - Right facing angle piece definition\nGM.L = function() {\n    return new GM.PcObj(\"rgb(255,129,51)\", 4, [\n        {\n            x: -1,\n            y: 0\n        },\n        {\n            x: 0,\n            y: 0\n        },\n        {\n            x: 1,\n            y: 0\n        },\n        {\n            x: -1,\n            y: -1\n        }\n    ]);\n};\n// J - Left facing angle piece definition\nGM.J = function() {\n    return new GM.PcObj(\"rgb(64,100,255)\", 4, [\n        {\n            x: -1,\n            y: 0\n        },\n        {\n            x: 0,\n            y: 0\n        },\n        {\n            x: 1,\n            y: 0\n        },\n        {\n            x: 1,\n            y: -1\n        }\n    ]);\n};\n// T - Hat shaped piece definition\nGM.T = function() {\n    return new GM.PcObj(\"rgb(160,62,255)\", 4, [\n        {\n            x: -1,\n            y: 0\n        },\n        {\n            x: 0,\n            y: 0\n        },\n        {\n            x: 1,\n            y: 0\n        },\n        {\n            x: 0,\n            y: -1\n        }\n    ]);\n};\n//--------------------------------------------------//\n//    ACTIVE PIECE CONTROLLER                       //\n//--------------------------------------------------//\n// Controls the generation, movement, and placement of piece \n// objects. Monitors the current piece and upcoming piece\nGM.Pc = {\n    //-- VARS ---------*/\n    // current piece, projected Y pos of cur piece  \n    Cur: 0,\n    ProjY: 0,\n    // upcoming pieces\n    Upcoming: [\n        0,\n        0,\n        0\n    ],\n    //-- FCNS ---------*/\n    // push upcoming piece to current & randomize new upcoming piece\n    Generate: function() {\n        // push upcoming piece to current and push down other upcomings\n        this.Cur = this.Upcoming[0];\n        this.Upcoming[0] = this.Upcoming[1];\n        this.Upcoming[1] = this.Upcoming[2];\n        // check if the player lost\n        if (this.Cur !== 0) {\n            var spawnCollisions = this.CheckCollisions(0, 0, 0);\n            if (spawnCollisions > 0) {\n                GM.GameOver();\n                this.Freeze();\n            }\n        }\n        // if player is alive, generate random upcoming piece\n        if (GM.IsAlive !== 0) {\n            var randInt = Math.floor(Math.random() * 7);\n            switch(randInt){\n                case 0:\n                    this.Upcoming[2] = GM.O();\n                    break;\n                case 1:\n                    this.Upcoming[2] = GM.I();\n                    break;\n                case 2:\n                    this.Upcoming[2] = GM.S();\n                    break;\n                case 3:\n                    this.Upcoming[2] = GM.Z();\n                    break;\n                case 4:\n                    this.Upcoming[2] = GM.L();\n                    break;\n                case 5:\n                    this.Upcoming[2] = GM.J();\n                    break;\n                case 6:\n                    this.Upcoming[2] = GM.T();\n                    break;\n                default:\n                    break;\n            }\n            // if a current piece was set, inform the GM\n            if (this.Cur !== 0) {\n                GM.PieceSpawned();\n                Page.Game.IsDirty = true;\n            }\n            Page.UpcomingA.IsDirty = Page.UpcomingB.IsDirty = Page.UpcomingC.IsDirty = true;\n        }\n    },\n    // freeze the current piece's position and rotation\n    Freeze: function() {\n        if (GM.IsAlive) {\n            var affectedRows = [];\n            for(var i = 0; i < this.Cur.UO.arr.length; i++){\n                var staticX = this.Cur.x + this.Cur.UO.arr[i].x, staticY = this.Cur.y + this.Cur.UO.arr[i].y;\n                if (staticY >= 0 && staticY <= GM.StaticUnits[0].length) {\n                    GM.StaticUnits[staticX][staticY] = this.Cur.color;\n                }\n                if (affectedRows.indexOf(staticY) < 0) {\n                    affectedRows.push(staticY);\n                }\n            }\n            GM.CheckUnits(affectedRows);\n            this.Generate();\n        }\n    },\n    // apply gravity to the current piece, checking for collisions\n    DoGravity: function() {\n        if (this.Cur !== 0) {\n            var collisions = this.CheckCollisions(0, 0, 1);\n            if (collisions === 0) {\n                this.Cur.y++;\n            } else {\n                this.Freeze();\n            }\n        }\n        GM.RefreshTimer();\n    },\n    // attempt to rotate the current piece, returns bool\n    TryRotate: function() {\n        if (this.Cur !== 0) {\n            var collisions = this.CheckCollisions(1, 0, 0);\n            if (collisions === 0) {\n                this.Cur.Rotate();\n                return true;\n            }\n        }\n        return false;\n    },\n    // attempt to move current piece base on given XY, returns bool\n    TryMove: function(moveX, moveY) {\n        if (this.Cur !== 0) {\n            var collisions = this.CheckCollisions(0, moveX, moveY);\n            if (collisions === 0) {\n                this.Cur.x += moveX;\n                this.Cur.y += moveY;\n                if (moveY > 0) {\n                    GM.RefreshTimer();\n                    GM.ScoreBonus++;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    // attempt to drop the current piece until it collides, returns bool\n    TryDrop: function() {\n        var squaresDropped = 0;\n        if (this.Cur !== 0) {\n            while(this.TryMove(0, 1) === true && squaresDropped < 22){\n                squaresDropped++;\n            }\n        }\n        if (squaresDropped > 0) {\n            GM.ScoreBonus += 2 * squaresDropped;\n            this.Freeze();\n            return true;\n        } else {\n            return false;\n        }\n    },\n    // attempt to find (and return) projected drop point of current piece\n    TryProject: function() {\n        var squaresDropped = 0;\n        if (this.Cur !== 0) {\n            while(this.CheckCollisions(0, 0, squaresDropped) === 0 && squaresDropped < 22){\n                squaresDropped++;\n            }\n        }\n        return squaresDropped - 1;\n    },\n    // return collision count OR -1 if test piece out of bounds\n    CheckCollisions: function(doRot, offsetX, offsetY) {\n        var unitArr, collisionCount = 0;\n        if (doRot === 1) {\n            unitArr = this.Cur.UO.nextUO.arr;\n        } else {\n            unitArr = this.Cur.UO.arr;\n        }\n        for(var i = 0; i < unitArr.length; i++){\n            var testX = this.Cur.x + unitArr[i].x + offsetX, testY = this.Cur.y + unitArr[i].y + offsetY, limitX = GM.StaticUnits.length, limitY = GM.StaticUnits[0].length;\n            if (testX < 0 || testX >= limitX || testY >= limitY) {\n                return -1;\n            } else if (testY > 0) {\n                if (GM.StaticUnits[testX][testY] !== 0) {\n                    collisionCount++;\n                }\n            }\n        }\n        return collisionCount;\n    }\n};\n//--------------------------------------------------//\n//    EVENT LISTENERS                               //\n//--------------------------------------------------//\n// Event for keyboard calls the corresponding manipulation functions\n// in GM.Pc based on user inputs. If manipulation is successful,\n// the page is marked as dirty.\ndocument.addEventListener(\"keydown\", function(evt) {\n    var key = event.keyCode || event.which;\n    if (GM.IsAlive) {\n        switch(key){\n            // Up arrow OR W = rotate     \n            case 38:\n            case 87:\n                Page.Game.IsDirty = GM.Pc.TryRotate();\n                break;\n            // Left arrow OR A = move left\n            case 37:\n            case 65:\n                Page.Game.IsDirty = GM.Pc.TryMove(-1, 0);\n                break;\n            // Right arrow OR D = move right  \n            case 39:\n            case 68:\n                Page.Game.IsDirty = GM.Pc.TryMove(1, 0);\n                break;\n            // Down arrow OR S = move down  \n            case 40:\n            case 83:\n                Page.Game.IsDirty = GM.Pc.TryMove(0, 1);\n                break;\n            // Spacebar to drop the current piece\n            case 32:\n                Page.Game.IsDirty = GM.Pc.TryDrop();\n                break;\n            default:\n                break;\n        }\n        //if board was dirtied, cast fresh projection for current piece\n        if (Page.Game.IsDirty) {\n            GM.Pc.ProjY = GM.Pc.TryProject();\n        }\n    } else {\n        Init();\n    }\n}, false);\n// Window resize event calls Page function to update the canvas \n// size/position, area bounds within the canvas, and the unitSize\nwindow.onresize = function(event1) {\n    Page.WindowChanged();\n};\n//--------------------------------------------------//\n//    INITIALAZATION AND GAME LOOP                  //\n//--------------------------------------------------//\n// Called on page load / game reset, Init fcn initializes \n// the Page and GM objects, then starts the main game loop.\nfunction Init() {\n    // initialize the page object\n    Page.Initialize();\n    // initialize the GM object\n    GM.Initialize();\n}\n_c1 = Init;\nInit();\n// Main game loop. Updates GM object to check if tick can be\n// performed. Then, if the page is dirty, performs a Draw.\nfunction Loop() {\n    // always update Page\n    Page.Update();\n    // only need to update GM if the player is alive\n    if (GM.IsAlive) {\n        GM.Update();\n    }\n    window.requestAnimationFrame(Loop);\n}\n_c2 = Loop;\nLoop();\n//--------------------------------------------------//\n//    HELPER FUNCTIONS                              //\n//--------------------------------------------------//\nfunction DrawText(text1, color, weight, alignment, size1, left, top) {\n    Page.ctx.font = weight + \" \" + size1 + 'px \"Jura\", sans-serif';\n    Page.ctx.textAlign = alignment;\n    Page.ctx.fillStyle = color;\n    Page.ctx.fillText(text1, left, top);\n}\n_c3 = DrawText;\nfunction ColorWithAlpha(color, alpha) {\n    var retColor = \"rgba\" + color.substring(3, color.length - 1);\n    retColor += \",\" + alpha + \")\";\n    return retColor;\n}\n_c4 = ColorWithAlpha;\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"DrawAreaObj\");\n$RefreshReg$(_c1, \"Init\");\n$RefreshReg$(_c2, \"Loop\");\n$RefreshReg$(_c3, \"DrawText\");\n$RefreshReg$(_c4, \"ColorWithAlpha\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUdXO0lBQ3JCMUUsS0FBS08sR0FBRyxDQUFDK0wsUUFBUSxDQUFDMUYsT0FBTWhGLE1BQU1HO0FBQ2hDO01BTFNrRDtBQU1ULFNBQVNSLGVBQWVDLEtBQUssRUFBRTZILEtBQUssRUFBRTtJQUNwQyxJQUFJQyxXQUFXLFNBQVM5SCxNQUFNK0gsU0FBUyxDQUFDLEdBQUcvSCxNQUFNakQsTUFBTSxHQUFHO0lBQzFEK0ssWUFBWSxNQUFNRCxRQUFRO0lBQzFCLE9BQU9DO0FBQ1Q7TUFKUy9IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL3RldHJpcy9wYWdlLmpzeD9jZWMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICBUT0RPOlxyXG4vLyAgICAqIHRvdWNoIGNvbnRyb2xzXHJcbi8vICAgICogYWxsb3cgbGF0ZSBwaWVjZSByb3RhdGlvblxyXG4vLyAgICAqIGNvZGUgY2xlYW51cFxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXHJcbi8vICAgIFBBR0UgT0JKRUNUICYgTE9HSUMgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cclxuXHJcbnZhciBQYWdlID0ge1xyXG4gICAgSXNTZXR1cDogZmFsc2UsXHJcbiAgICBib2R5OiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdLFxyXG4gICAgY3ZzOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcclxuICAgIGN0eDogMCxcclxuICAgIHVuaXRTaXplOiAwLFxyXG4gICAgQXJlYUFycjogW10sXHJcbiAgICAvLyBjYWxjdWxhdGVzIHRoZSB1bml0IHNpemUsIGNhbnZhcyBib3VuZHMsIGFuZCBjYW52YXMgcG9zaXRpb25pbmdcclxuICAgIFdpbmRvd0NoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gQ2FsdWxjYXRlIHRoZSB1bml0U2l6ZSBiYXNlZCBvbiB3aW5kb3cgd2lkdGggYW5kIGhlaWdodC5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gb2YgdGhlc2UgY2FsY3VsYXRpb25zIHdpbGwgYmUgdXNlZC5cclxuICBcclxuICAgICAgdmFyIGJvZHlXID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxyXG4gICAgICAgIGJvZHlIID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxcclxuICAgICAgICBuZXdVbml0VyA9IChib2R5VyAtIGJvZHlXICUgODApIC8gMTYsXHJcbiAgICAgICAgbmV3VW5pdEggPSAoYm9keUggLSBib2R5SCAlIDEwMCkgLyAyMCxcclxuICAgICAgICBuZXdVbml0TWluID0gTWF0aC5tYXgoTWF0aC5taW4obmV3VW5pdFcsIG5ld1VuaXRIKSwgMjApO1xyXG4gIFxyXG4gICAgICAvLyBpZiB0aGUgY2FsY1VuaXRNaW4gIT0gdW5pdFNpemUsIHVwZGF0ZSB1bml0U2l6ZSwgcmVjYWxjdWxhdGVcclxuICAgICAgLy8gYWxsIERyYXdBcmVhT2JqcywgYW5kIHVwZGF0ZSB0aGUgY2FudmFzIGVsZW1lbnQgYm91bmRzXHJcbiAgXHJcbiAgICAgIHRoaXMudW5pdFNpemUgPSBuZXdVbml0TWluO1xyXG4gIFxyXG4gICAgICAvLyBzdG9yZSBSaWdodC1tb3N0ICYgQm90dG9tLW1vc3QgcG9pbnRzIGZvciBjYW52YXMgYm91bmRzXHJcbiAgICAgIHZhciByaWdodExpbWl0ID0gMCxcclxuICAgICAgICBib3R0b21MaW1pdCA9IDA7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUGFnZS5BcmVhQXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgUGFnZS5BcmVhQXJyW2ldLkNhbGN1bGF0ZUJvdW5kcygpO1xyXG4gICAgICAgIHZhciBuZXdSaWdodExpbWl0ID0gUGFnZS5BcmVhQXJyW2ldLmxlZnQgKyBQYWdlLkFyZWFBcnJbaV0uVyxcclxuICAgICAgICAgIG5ld0JvdHRvbUxpbWl0ID0gUGFnZS5BcmVhQXJyW2ldLnRvcCArIFBhZ2UuQXJlYUFycltpXS5IO1xyXG4gICAgICAgIHJpZ2h0TGltaXQgPSBNYXRoLm1heChuZXdSaWdodExpbWl0LCByaWdodExpbWl0KTtcclxuICAgICAgICBib3R0b21MaW1pdCA9IE1hdGgubWF4KG5ld0JvdHRvbUxpbWl0LCBib3R0b21MaW1pdCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jdnMud2lkdGggPSByaWdodExpbWl0O1xyXG4gICAgICB0aGlzLmN2cy5oZWlnaHQgPSBib3R0b21MaW1pdDtcclxuICBcclxuICAgICAgLy8gbGVmdCBwb3MgdXNlcyBHYW1lLlcgYmVjYXVzZSBpZGVhbGx5IHRoYXQgYXJlYSBpcyBjZW50ZXJlZFxyXG4gICAgICB2YXIgdG9wUG9zID0gKGJvZHlIIC0gYm90dG9tTGltaXQpIC8gMixcclxuICAgICAgICBsZWZ0UG9zID0gYm9keVcgLyAyIC0gdGhpcy5HYW1lLlcgLyAyLFxyXG4gICAgICAgIHJpZ2h0T2Zmc2V0ID0gYm9keVcgLSAobGVmdFBvcyArIHJpZ2h0TGltaXQpIC0gdGhpcy51bml0U2l6ZSAqIDAuNTtcclxuICBcclxuICAgICAgLy8gaWYgZGVmYXVsdCBjYW52YXMgcG9zaXRpb25pbmcgZXh0ZW5kcyBiZXlvbmQgc2NyZWVuLCBhZGp1c3QgaXRcclxuICAgICAgaWYgKHJpZ2h0T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgIGxlZnRQb3MgPSBNYXRoLm1heCh0aGlzLnVuaXRTaXplICogMC41LCBsZWZ0UG9zICsgcmlnaHRPZmZzZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY3ZzLnN0eWxlLmxlZnQgPSBsZWZ0UG9zICsgJ3B4JztcclxuICAgICAgdGhpcy5jdnMuc3R5bGUudG9wID0gdG9wUG9zICsgJ3B4JztcclxuICAgIH0sXHJcbiAgICAvLyBwZXJmb3JtcyB0aGUgcGFnZSBzZXR1cFxyXG4gICAgSW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAvLyBpZiBwYWdlIGhhcyBub3QgYmVlbiBzZXR1cCwgZG8gaW5pdGlhbCBzZXR1cFxyXG4gICAgICBpZiAodGhpcy5Jc1NldHVwID09PSBmYWxzZSkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoUGFnZS5jdnMpO1xyXG4gICAgICAgIHRoaXMuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gICAgICAgIHRoaXMuYm9keS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiKDE5LDIxLDI1KSc7XHJcbiAgICAgICAgdGhpcy5jdnMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jdnMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB0aGlzLklzU2V0dXAgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuV2luZG93Q2hhbmdlZCgpO1xyXG4gIFxyXG4gICAgICAvLyBkaXJ0eSBhbGwgZHJhdyBhcmVhc1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFBhZ2UuQXJlYUFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIFBhZ2UuQXJlYUFycltpXS5Jc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIHJlZHJhd3MgY2FudmFzIHZpc3VhbHMgd2hlbmV2ZXIgdGhlIHBhZ2UgaXMgbWFya2VkIGFzIGRpcnR5XHJcbiAgICBVcGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBQYWdlLkFyZWFBcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoUGFnZS5BcmVhQXJyW2ldLklzRGlydHkpIHtcclxuICAgICAgICAgIFBhZ2UuQXJlYUFycltpXS5EcmF3KCk7XHJcbiAgICAgICAgICBQYWdlLkFyZWFBcnJbaV0uSXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbiAgXHJcbiAgLy8gRGVmaW5pdGlvbiBmb3IgQXJlYSBvYmplY3RzLiBCb3VuZHMgYXJlIGluIFVOSVRTXHJcbiAgZnVuY3Rpb24gRHJhd0FyZWFPYmooTGVmdCwgVG9wLCBXaWR0aCwgSGVpZ2h0LCBEcmF3RnVuY3Rpb24pIHtcclxuICAgIC8vIGJvdW5kcyBpbiBVTklUU1xyXG4gICAgdGhpcy5sZWZ0QmFzZSA9IExlZnQ7XHJcbiAgICB0aGlzLnRvcEJhc2UgPSBUb3A7XHJcbiAgICB0aGlzLndpZHRoQmFzZSA9IFdpZHRoO1xyXG4gICAgdGhpcy5oZWlnaHRCYXNlID0gSGVpZ2h0O1xyXG4gIFxyXG4gICAgLy8gYm91bmRzIGluIFBJWEVMU1xyXG4gICAgdGhpcy5sZWZ0ID0gMDtcclxuICAgIHRoaXMudG9wID0gMDtcclxuICAgIHRoaXMuVyA9IDA7XHJcbiAgICB0aGlzLkggPSAwO1xyXG4gIFxyXG4gICAgLy8gZGlydHkgZmxhZyAoY2xlYW4geW91cnNlbGYgdXAgZmxhZywgeW91J3JlIGJldHRlciB0aGFuIHRoYXQpXHJcbiAgICB0aGlzLklzRGlydHkgPSBmYWxzZTtcclxuICBcclxuICAgIC8vIGJvdW5kcyByZWNhbGN1bGF0ZWQgYW5kIGFyZWEgZGlydGllZCB3aGVuIHVuaXRTaXplIGNoYW5nZXNcclxuICAgIHRoaXMuQ2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmxlZnQgPSB0aGlzLmxlZnRCYXNlICogUGFnZS51bml0U2l6ZTtcclxuICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcEJhc2UgKiBQYWdlLnVuaXRTaXplO1xyXG4gICAgICB0aGlzLlcgPSB0aGlzLndpZHRoQmFzZSAqIFBhZ2UudW5pdFNpemU7XHJcbiAgICAgIHRoaXMuSCA9IHRoaXMuaGVpZ2h0QmFzZSAqIFBhZ2UudW5pdFNpemU7XHJcbiAgICAgIHRoaXMuSXNEaXJ0eSA9IHRydWU7XHJcbiAgICB9O1xyXG4gIFxyXG4gICAgLy8gZHJhdyBmdW5jdGlvbiBhcyBwYXNzZWQgaW4gYnkgdGhlIGNhbGxlZVxyXG4gICAgdGhpcy5EcmF3ID0gRHJhd0Z1bmN0aW9uO1xyXG4gIFxyXG4gICAgLy8gcHVzaCB0aGlzIGFyZWEgaW50byB0aGUgYXJlYSBhcnIgICAgXHJcbiAgICBQYWdlLkFyZWFBcnIucHVzaCh0aGlzKTtcclxuICB9XHJcbiAgUGFnZS5HYW1lID0gbmV3IERyYXdBcmVhT2JqKDAsIDAsIDEwLCAyMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gdW5pdFNpemUgbWludXMgYSBjb3VwbGUgcGl4ZWxzIG9mIHNlcGFyYXRpb25cclxuICAgIHZhciB1RHJhd1NpemUgPSBQYWdlLnVuaXRTaXplIC0gMixcclxuICAgICAgZHJhd0wsXHJcbiAgICAgIGRyYXdUO1xyXG4gIFxyXG4gICAgLy8gcmVkcmF3cyB0aGUgYmFja2dyb3VuZCBlbGVtZW50cyBmb3IgZ2FtZSBhcmVhXHJcbiAgICBQYWdlLmN0eC5maWxsU3R5bGUgPSAncmdiKDI4LDMwLDM0KSc7XHJcbiAgICBQYWdlLmN0eC5maWxsUmVjdCh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLlcsIHRoaXMuSCk7XHJcbiAgXHJcbiAgICAvLyBkcmF3IHRoZSBzdGF0aWMgdW5pdCBibG9ja3NcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgR00uU3RhdGljVW5pdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBHTS5TdGF0aWNVbml0c1tpXS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIC8vIGdldCB0aGUgdW5pdCB2YWx1ZSBmb3IgdGhpcyBpbmRleCBwYWlyXHJcbiAgICAgICAgdmFyIHVWYWx1ZSA9IEdNLlN0YXRpY1VuaXRzW2ldW2pdO1xyXG4gIFxyXG4gICAgICAgIC8vIGlmIHRoaXMgdW5pdCB2YWx1ZSBpcyBub3QgMCwgZHJhdyB0aGUgdW5pdFxyXG4gICAgICAgIGlmICh1VmFsdWUgIT09IDApIHtcclxuICAgICAgICAgIGRyYXdMID0gaSAqIFBhZ2UudW5pdFNpemUgKyAxO1xyXG4gICAgICAgICAgZHJhd1QgPSBqICogUGFnZS51bml0U2l6ZSArIDE7XHJcbiAgXHJcbiAgICAgICAgICAvLyBmaWxsIHRoaXMgc3F1YXJlIHdpdGggY29sb3IgYmFzZWQgb24gcGxheWVyIGFsaXZlIHN0YXR1cyAgICAgICAgXHJcbiAgICAgICAgICBQYWdlLmN0eC5maWxsU3R5bGUgPSBHTS5Jc0FsaXZlID8gdVZhbHVlIDogJ3JnYigzNCwzNiw0MiknO1xyXG4gICAgICAgICAgUGFnZS5jdHguZmlsbFJlY3QoZHJhd0wsIGRyYXdULCB1RHJhd1NpemUsIHVEcmF3U2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBkcmF3IHRoZSBjdXJyZW50IGFjdGl2ZSBwcm9qZWN0aW9uIGFuZCBwaWVjZSAoaWYgZXhpc3RzKVxyXG4gICAgaWYgKEdNLlBjLkN1ciAhPT0gMCAmJiBHTS5Jc0FsaXZlKSB7XHJcbiAgICAgIHZhciBwcm9qQ29sb3IgPSBDb2xvcldpdGhBbHBoYShHTS5QYy5DdXIuY29sb3IsIDAuMSk7XHJcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgR00uUGMuQ3VyLlVPLmFyci5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgIGRyYXdMID0gKEdNLlBjLkN1ci54ICsgR00uUGMuQ3VyLlVPLmFycltrXS54KSAqIFBhZ2UudW5pdFNpemUgKyAxO1xyXG4gICAgICAgIGRyYXdUID0gKEdNLlBjLkN1ci55ICsgR00uUGMuQ3VyLlVPLmFycltrXS55KSAqIFBhZ2UudW5pdFNpemUgKyAxO1xyXG4gICAgICAgIFBhZ2UuY3R4LmZpbGxTdHlsZSA9IEdNLlBjLkN1ci5jb2xvcjtcclxuICAgICAgICBQYWdlLmN0eC5maWxsUmVjdChkcmF3TCwgZHJhd1QsIHVEcmF3U2l6ZSwgdURyYXdTaXplKTtcclxuICBcclxuICAgICAgICAvLyBhbHNvIGRyYXcgdGhlIHByb2plY3Rpb24gKGlmIG9uZSBleGlzdHMpXHJcbiAgICAgICAgaWYgKEdNLklzQWxpdmUgJiYgR00uUGMuUHJvalkgIT09IDApIHtcclxuICAgICAgICAgIGRyYXdUICs9IEdNLlBjLlByb2pZICogUGFnZS51bml0U2l6ZTtcclxuICAgICAgICAgIFBhZ2UuY3R4LmZpbGxTdHlsZSA9IHByb2pDb2xvcjtcclxuICAgICAgICAgIFBhZ2UuY3R4LmZpbGxSZWN0KGRyYXdMLCBkcmF3VCwgdURyYXdTaXplLCB1RHJhd1NpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgLy8gaWYgdGhlIHBsYXllciBpcyBkZWFkLCBkcmF3IHRoZSBnYW1lIG92ZXIgdGV4dFxyXG4gICAgaWYgKCFHTS5Jc0FsaXZlKSB7XHJcbiAgICAgIERyYXdUZXh0KFwiR0FNRSBPVkVSXCIsICdyZ2IoMjU1LDI1NSwyNTUpJywgJzUwMCcsICdjZW50ZXInLCB1RHJhd1NpemUsIHRoaXMuVyAvIDIsIHRoaXMuSCAvIDQpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFBhZ2UuVXBjb21pbmdBID0gbmV3IERyYXdBcmVhT2JqKDEwLjUsIDIuNiwgMi41LCAyLjUsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB1RHJhd1NpemUgPSBNYXRoLmZsb29yKFBhZ2UudW5pdFNpemUgLyAyKSxcclxuICAgICAgcGNBID0gR00uUGMuVXBjb21pbmdbMF07XHJcbiAgXHJcbiAgICAvLyBuZXh0IGJveCBiYWNrZ3JvdW5kXHJcbiAgICBQYWdlLmN0eC5maWxsU3R5bGUgPSAncmdiKDI4LDMwLDM0KSc7XHJcbiAgICBQYWdlLmN0eC5maWxsUmVjdCh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLlcsIHRoaXMuSCk7XHJcbiAgXHJcbiAgICAvLyBkcmF3IHRoZSB1cGNvbWluZyBwaWVjZSAoaWYgb25lIGV4aXN0cylcclxuICAgIGlmIChwY0EgIT09IDApIHtcclxuICAgICAgUGFnZS5jdHguZmlsbFN0eWxlID0gcGNBLmNvbG9yO1xyXG4gICAgICB2YXIgdG90YWxMID0gMCxcclxuICAgICAgICB0b3RhbFQgPSAwLFxyXG4gICAgICAgIGNvdW50ZWRMID0gW10sXHJcbiAgICAgICAgY291bnRlZFQgPSBbXTtcclxuICBcclxuICAgICAgLy8gY2FsY3VsYXRlIGF2ZXJhZ2UgcG9zaXRpb25zIG9mIHVuaXRzIGluIG9yZGVyIHRvIGNlbnRlclxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBjQS5VTy5hcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgY3VyWCA9IHBjQS5VTy5hcnJbaV0ueCxcclxuICAgICAgICAgIGN1clkgPSBwY0EuVU8uYXJyW2ldLnk7XHJcbiAgICAgICAgaWYgKGNvdW50ZWRMLmluZGV4T2YoY3VyWCkgPCAwKSB7XHJcbiAgICAgICAgICBjb3VudGVkTC5wdXNoKGN1clgpO1xyXG4gICAgICAgICAgdG90YWxMICs9IGN1clg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3VudGVkVC5pbmRleE9mKGN1clkpIDwgMCkge1xyXG4gICAgICAgICAgY291bnRlZFQucHVzaChjdXJZKTtcclxuICAgICAgICAgIHRvdGFsVCArPSBjdXJZO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB2YXIgYXZnTCA9IHVEcmF3U2l6ZSAqICh0b3RhbEwgLyBjb3VudGVkTC5sZW5ndGggKyAwLjUpLFxyXG4gICAgICAgIGF2Z1QgPSB1RHJhd1NpemUgKiAodG90YWxUIC8gY291bnRlZFQubGVuZ3RoICsgMC41KSxcclxuICAgICAgICBvZmZzZXRMID0gdGhpcy5sZWZ0ICsgdGhpcy5XIC8gMixcclxuICAgICAgICBvZmZzZXRUID0gdGhpcy50b3AgKyB0aGlzLkggLyAyO1xyXG4gICAgICBjb25zb2xlLmxvZyhhdmdMICsgXCIsIFwiICsgYXZnVCk7XHJcbiAgXHJcbiAgICAgIC8vIG5vdyBkcmF3IHRoZSB1cGNvbWluZyBwaWVjZSwgdXNpbmcgYXZnIHZhcnMgdG8gY2VudGVyXHJcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGNBLlVPLmFyci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHZhciBkcmF3TCA9IE1hdGguZmxvb3Iob2Zmc2V0TCAtIGF2Z0wgKyBwY0EuVU8uYXJyW2pdLnggKiB1RHJhd1NpemUpLFxyXG4gICAgICAgICAgZHJhd1QgPSBNYXRoLmZsb29yKG9mZnNldFQgLSBhdmdUICsgcGNBLlVPLmFycltqXS55ICogdURyYXdTaXplKTtcclxuICAgICAgICBQYWdlLmN0eC5maWxsUmVjdChkcmF3TCwgZHJhd1QsIHVEcmF3U2l6ZSAtIDEsIHVEcmF3U2l6ZSAtIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgUGFnZS5VcGNvbWluZ0IgPSBuZXcgRHJhd0FyZWFPYmooMTAuNSwgNS4yLCAyLjUsIDIuNSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHVEcmF3U2l6ZSA9IE1hdGguZmxvb3IoUGFnZS51bml0U2l6ZSAvIDIpLFxyXG4gICAgICBwY0IgPSBHTS5QYy5VcGNvbWluZ1sxXTtcclxuICBcclxuICAgIC8vIG5leHQgYm94IGJhY2tncm91bmRcclxuICAgIFBhZ2UuY3R4LmZpbGxTdHlsZSA9ICdyZ2IoMjgsMzAsMzQpJztcclxuICAgIFBhZ2UuY3R4LmZpbGxSZWN0KHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMuVywgdGhpcy5IKTtcclxuICBcclxuICAgIC8vIGRyYXcgdGhlIHVwY29taW5nIHBpZWNlIChpZiBvbmUgZXhpc3RzKVxyXG4gICAgaWYgKHBjQiAhPT0gMCkge1xyXG4gICAgICBQYWdlLmN0eC5maWxsU3R5bGUgPSBwY0IuY29sb3I7XHJcbiAgICAgIHZhciB0b3RhbEwgPSAwLFxyXG4gICAgICAgIHRvdGFsVCA9IDAsXHJcbiAgICAgICAgY291bnRlZEwgPSBbXSxcclxuICAgICAgICBjb3VudGVkVCA9IFtdO1xyXG4gIFxyXG4gICAgICAvLyBjYWxjdWxhdGUgYXZlcmFnZSBwb3NpdGlvbnMgb2YgdW5pdHMgaW4gb3JkZXIgdG8gY2VudGVyXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGNCLlVPLmFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjdXJYID0gcGNCLlVPLmFycltpXS54LFxyXG4gICAgICAgICAgY3VyWSA9IHBjQi5VTy5hcnJbaV0ueTtcclxuICAgICAgICBpZiAoY291bnRlZEwuaW5kZXhPZihjdXJYKSA8IDApIHtcclxuICAgICAgICAgIGNvdW50ZWRMLnB1c2goY3VyWCk7XHJcbiAgICAgICAgICB0b3RhbEwgKz0gY3VyWDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvdW50ZWRULmluZGV4T2YoY3VyWSkgPCAwKSB7XHJcbiAgICAgICAgICBjb3VudGVkVC5wdXNoKGN1clkpO1xyXG4gICAgICAgICAgdG90YWxUICs9IGN1clk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHZhciBhdmdMID0gdURyYXdTaXplICogKHRvdGFsTCAvIGNvdW50ZWRMLmxlbmd0aCArIDAuNSksXHJcbiAgICAgICAgYXZnVCA9IHVEcmF3U2l6ZSAqICh0b3RhbFQgLyBjb3VudGVkVC5sZW5ndGggKyAwLjUpLFxyXG4gICAgICAgIG9mZnNldEwgPSB0aGlzLmxlZnQgKyB0aGlzLlcgLyAyLFxyXG4gICAgICAgIG9mZnNldFQgPSB0aGlzLnRvcCArIHRoaXMuSCAvIDI7XHJcbiAgICAgIGNvbnNvbGUubG9nKGF2Z0wgKyBcIiwgXCIgKyBhdmdUKTtcclxuICBcclxuICAgICAgLy8gbm93IGRyYXcgdGhlIHVwY29taW5nIHBpZWNlLCB1c2luZyBhdmcgdmFycyB0byBjZW50ZXJcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwY0IuVU8uYXJyLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgdmFyIGRyYXdMID0gTWF0aC5mbG9vcihvZmZzZXRMIC0gYXZnTCArIHBjQi5VTy5hcnJbal0ueCAqIHVEcmF3U2l6ZSksXHJcbiAgICAgICAgICBkcmF3VCA9IE1hdGguZmxvb3Iob2Zmc2V0VCAtIGF2Z1QgKyBwY0IuVU8uYXJyW2pdLnkgKiB1RHJhd1NpemUpO1xyXG4gICAgICAgIFBhZ2UuY3R4LmZpbGxSZWN0KGRyYXdMLCBkcmF3VCwgdURyYXdTaXplIC0gMSwgdURyYXdTaXplIC0gMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICBQYWdlLlVwY29taW5nQyA9IG5ldyBEcmF3QXJlYU9iaigxMC41LCA3LjgsIDIuNSwgMi41LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdURyYXdTaXplID0gTWF0aC5mbG9vcihQYWdlLnVuaXRTaXplIC8gMiksXHJcbiAgICAgIHBjQyA9IEdNLlBjLlVwY29taW5nWzJdO1xyXG4gIFxyXG4gICAgLy8gbmV4dCBib3ggYmFja2dyb3VuZFxyXG4gICAgUGFnZS5jdHguZmlsbFN0eWxlID0gJ3JnYigyOCwzMCwzNCknO1xyXG4gICAgUGFnZS5jdHguZmlsbFJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5XLCB0aGlzLkgpO1xyXG4gIFxyXG4gICAgLy8gZHJhdyB0aGUgdXBjb21pbmcgcGllY2UgKGlmIG9uZSBleGlzdHMpXHJcbiAgICBpZiAocGNDICE9PSAwKSB7XHJcbiAgICAgIFBhZ2UuY3R4LmZpbGxTdHlsZSA9IHBjQy5jb2xvcjtcclxuICAgICAgdmFyIHRvdGFsTCA9IDAsXHJcbiAgICAgICAgdG90YWxUID0gMCxcclxuICAgICAgICBjb3VudGVkTCA9IFtdLFxyXG4gICAgICAgIGNvdW50ZWRUID0gW107XHJcbiAgXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSBhdmVyYWdlIHBvc2l0aW9ucyBvZiB1bml0cyBpbiBvcmRlciB0byBjZW50ZXJcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwY0MuVU8uYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGN1clggPSBwY0MuVU8uYXJyW2ldLngsXHJcbiAgICAgICAgICBjdXJZID0gcGNDLlVPLmFycltpXS55O1xyXG4gICAgICAgIGlmIChjb3VudGVkTC5pbmRleE9mKGN1clgpIDwgMCkge1xyXG4gICAgICAgICAgY291bnRlZEwucHVzaChjdXJYKTtcclxuICAgICAgICAgIHRvdGFsTCArPSBjdXJYO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY291bnRlZFQuaW5kZXhPZihjdXJZKSA8IDApIHtcclxuICAgICAgICAgIGNvdW50ZWRULnB1c2goY3VyWSk7XHJcbiAgICAgICAgICB0b3RhbFQgKz0gY3VyWTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGF2Z0wgPSB1RHJhd1NpemUgKiAodG90YWxMIC8gY291bnRlZEwubGVuZ3RoICsgMC41KSxcclxuICAgICAgICBhdmdUID0gdURyYXdTaXplICogKHRvdGFsVCAvIGNvdW50ZWRULmxlbmd0aCArIDAuNSksXHJcbiAgICAgICAgb2Zmc2V0TCA9IHRoaXMubGVmdCArIHRoaXMuVyAvIDIsXHJcbiAgICAgICAgb2Zmc2V0VCA9IHRoaXMudG9wICsgdGhpcy5IIC8gMjtcclxuICAgICAgY29uc29sZS5sb2coYXZnTCArIFwiLCBcIiArIGF2Z1QpO1xyXG4gIFxyXG4gICAgICAvLyBub3cgZHJhdyB0aGUgdXBjb21pbmcgcGllY2UsIHVzaW5nIGF2ZyB2YXJzIHRvIGNlbnRlclxyXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBjQy5VTy5hcnIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICB2YXIgZHJhd0wgPSBNYXRoLmZsb29yKG9mZnNldEwgLSBhdmdMICsgcGNDLlVPLmFycltqXS54ICogdURyYXdTaXplKSxcclxuICAgICAgICAgIGRyYXdUID0gTWF0aC5mbG9vcihvZmZzZXRUIC0gYXZnVCArIHBjQy5VTy5hcnJbal0ueSAqIHVEcmF3U2l6ZSk7XHJcbiAgICAgICAgUGFnZS5jdHguZmlsbFJlY3QoZHJhd0wsIGRyYXdULCB1RHJhd1NpemUgLSAxLCB1RHJhd1NpemUgLSAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFBhZ2UuU2NvcmVCYXJIaWdoID0gbmV3IERyYXdBcmVhT2JqKDEwLjUsIDAsIDQuNSwgMSwgZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gZHJhdyB0aGUgc2NvcmUgYXJlYSBiYWNrIGJhclxyXG4gICAgUGFnZS5jdHguZmlsbFN0eWxlID0gJ3JnYigyOCwzMCwzNCknO1xyXG4gICAgUGFnZS5jdHguZmlsbFJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5XLCB0aGlzLkgpO1xyXG4gIFxyXG4gICAgLy8gRHJhdyB0aGUgdHJvcGh5IHN5bWJvbFxyXG4gIFxyXG4gICAgdmFyIG1pbmlVbml0LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQ7XHJcbiAgICBtaW5pVW5pdCA9IFBhZ2UudW5pdFNpemUgKiAwLjAxO1xyXG4gICAgUGFnZS5jdHguZmlsbFN0eWxlID0gJ3JnYigyNTUsMjMyLDk2KSc7XHJcbiAgXHJcbiAgICAvLyB0cm9waHkgYmFzZVxyXG4gICAgbGVmdCA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgbWluaVVuaXQgKiAzMyk7XHJcbiAgICB0b3AgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgdGhpcy5IIC0gbWluaVVuaXQgKiAyOCk7XHJcbiAgICB3aWR0aCA9IE1hdGguZmxvb3IobWluaVVuaXQgKiAzMCk7XHJcbiAgICBoZWlnaHQgPSBNYXRoLmZsb29yKG1pbmlVbml0ICogMTIpO1xyXG4gICAgUGFnZS5jdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxuICBcclxuICAgIC8vIHRyb3BoeSB0cnVua1xyXG4gICAgbGVmdCA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgbWluaVVuaXQgKiA0Mik7XHJcbiAgICB0b3AgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgdGhpcy5IIC0gbWluaVVuaXQgKiA1MCk7XHJcbiAgICB3aWR0aCA9IE1hdGguZmxvb3IobWluaVVuaXQgKiAxMik7XHJcbiAgICBoZWlnaHQgPSBNYXRoLmZsb29yKG1pbmlVbml0ICogMzIpO1xyXG4gICAgUGFnZS5jdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxuICBcclxuICAgIC8vIHRyb3BoeSBib3dsXHJcbiAgICBsZWZ0ID0gTWF0aC5mbG9vcih0aGlzLmxlZnQgKyBtaW5pVW5pdCAqIDQ4KTtcclxuICAgIHRvcCA9IE1hdGguZmxvb3IodGhpcy50b3AgKyB0aGlzLkggLSBtaW5pVW5pdCAqIDY4KTtcclxuICAgIFBhZ2UuY3R4LmFyYyhsZWZ0LCB0b3AsIG1pbmlVbml0ICogMjQsIDAsIE1hdGguUEkpO1xyXG4gICAgUGFnZS5jdHguZmlsbCgpO1xyXG4gIFxyXG4gICAgLy8gZHJhdyB0aGUgcGxheWVyJ3MgY3VycmVudCBzY29yZVxyXG4gICAgdGV4dCA9IChcIjAwMDAwMDAwXCIgKyBHTS5TY29yZUhpZ2gpLnNsaWNlKC03KTtcclxuICAgIGxlZnQgPSB0aGlzLmxlZnQgKyB0aGlzLlcgLSA0O1xyXG4gICAgdG9wID0gdGhpcy50b3AgKyBQYWdlLnVuaXRTaXplICogMC44O1xyXG4gICAgc2l6ZSA9IE1hdGguZmxvb3IoUGFnZS51bml0U2l6ZSAqIDAuOCkgKyAwLjU7XHJcbiAgICBEcmF3VGV4dCh0ZXh0LCAncmdiKDI1NSwyMzIsOTYpJywgJzUwMCcsICdyaWdodCcsIHNpemUsIGxlZnQsIHRvcCk7XHJcbiAgfSk7XHJcbiAgUGFnZS5TY29yZUJhckN1ciA9IG5ldyBEcmF3QXJlYU9iaigxMC41LCAxLjEsIDQuNSwgMSwgZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gZHJhdyB0aGUgc2NvcmUgYXJlYSBiYWNrIGJhclxyXG4gICAgUGFnZS5jdHguZmlsbFN0eWxlID0gJ3JnYigyOCwzMCwzNCknO1xyXG4gICAgUGFnZS5jdHguZmlsbFJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5XLCB0aGlzLkgpO1xyXG4gIFxyXG4gICAgLy8gZHJhdyB0aGUgcGxheWVyJ3MgY3VycmVudCBsZXZlbFxyXG4gICAgdmFyIHRleHQsIGxlZnQsIHRvcCwgc2l6ZSwgbWluaVVuaXQ7XHJcbiAgICBtaW5pVW5pdCA9IFBhZ2UudW5pdFNpemUgKiAwLjAxO1xyXG4gICAgdGV4dCA9ICgnMDAnICsgR00uTGV2ZWwpLnNsaWNlKC0yKTtcclxuICAgIGxlZnQgPSB0aGlzLmxlZnQgKyBNYXRoLmZsb29yKG1pbmlVbml0ICogNTApO1xyXG4gICAgdG9wID0gdGhpcy50b3AgKyBQYWdlLnVuaXRTaXplICogMC44O1xyXG4gICAgc2l6ZSA9IE1hdGguZmxvb3IoUGFnZS51bml0U2l6ZSAqIDAuNSk7XHJcbiAgICBEcmF3VGV4dCh0ZXh0LCAncmdiKDEyOCwxMjgsMTI4KScsICc5MDAnLCAnY2VudGVyJywgc2l6ZSwgbGVmdCwgdG9wKTtcclxuICBcclxuICAgIC8vIGRyYXcgdGhlIHBsYXllcidzIGN1cnJlbnQgc2NvcmVcclxuICAgIHRleHQgPSAoXCIwMDAwMDAwMFwiICsgR00uU2NvcmVDdXIpLnNsaWNlKC03KTtcclxuICAgIGxlZnQgPSB0aGlzLmxlZnQgKyB0aGlzLlcgLSA0O1xyXG4gICAgdG9wID0gdGhpcy50b3AgKyBQYWdlLnVuaXRTaXplICogMC44O1xyXG4gICAgc2l6ZSA9IE1hdGguZmxvb3IoUGFnZS51bml0U2l6ZSAqIDAuOCkgKyAwLjU7XHJcbiAgICBEcmF3VGV4dCh0ZXh0LCAncmdiKDI1NSwyNTUsMjU1KScsICc1MDAnLCAncmlnaHQnLCBzaXplLCBsZWZ0LCB0b3ApO1xyXG4gIH0pO1xyXG4gIFxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIC8vICAgIEdBTUUgTUFOQUdFUiBPQkpFQ1QgJiBMT0dJQyAgICAgICAgICAgICAgICAgICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIFxyXG4gIHZhciBHTSA9IHtcclxuICAgIC8vLS0gVkFSUyAtLS0tLS0tLS0qL1xyXG4gIFxyXG4gICAgLy8gdGltZXJzXHJcbiAgICBUaW1lQ3VyOiAwLFxyXG4gICAgVGltZUV2ZW50OiAwLFxyXG4gICAgVGlja1JhdGU6IDAsXHJcbiAgICAvLyBwbGF5ZXIgc3RhdHVzICYgc2NvcmVcclxuICAgIElzQWxpdmU6IDAsXHJcbiAgICBMZXZlbDogMCxcclxuICAgIFBpZWNlc1JlbWFpbmluZzogMCxcclxuICAgIC8vIHNjb3JlIGNvdW50IGFuZCBjdXJyZW50IHBpZWNlIHNjb3JlIG1vZGlmaWVyc1xyXG4gICAgU2NvcmVIaWdoOiAwLFxyXG4gICAgU2NvcmVDdXI6IDAsXHJcbiAgICBTY29yZUJvbnVzOiAwLFxyXG4gICAgRGlmZmljdWx0RmxhZzogMCxcclxuICAgIC8vIGFycmF5IG9mIGdyaWQgc3F1YXJlc1xyXG4gICAgU3RhdGljVW5pdHM6IFtdLFxyXG4gICAgLyotLSBGQ05TIC0tLS0tLS0tLSovXHJcbiAgXHJcbiAgICAvLyBTZXQgdXAgaW50aWFsIGdhbWUgdmFyIHZhbHVlc1xyXG4gICAgSW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAvLyByZXNldCBjdXJyZW50IHBpZWNlIHZhcnNcclxuICAgICAgdGhpcy5QYy5OZXh0ID0gdGhpcy5QYy5DdXIgPSB0aGlzLlBjLlByb2pZID0gMDtcclxuICBcclxuICAgICAgLy8gcG9wdWxhdGUgdGhlIEdNJ3Mgc3RhdGljIHVuaXQgYXJyYXkgd2l0aCAwJ3MgKGVtcHR5KVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcclxuICAgICAgICB0aGlzLlN0YXRpY1VuaXRzW2ldID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyMDsgaisrKSB7XHJcbiAgICAgICAgICB0aGlzLlN0YXRpY1VuaXRzW2ldW2pdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLy8gcmVzZXQgdGltZXJcclxuICAgICAgdGhpcy5UaW1lQ3VyID0gdGhpcy5UaW1lRXZlbnQgPSAwO1xyXG4gICAgICB0aGlzLlRpY2tSYXRlID0gNTAwO1xyXG4gIFxyXG4gICAgICAvLyBzZXQgdXAgbGV2ZWwgdmFsdWVzIGZvciBsZXZlbCAxXHJcbiAgICAgIHRoaXMuUGllY2VzUmVtYWluaW5nID0gMTA7XHJcbiAgICAgIHRoaXMuTGV2ZWwgPSAxO1xyXG4gIFxyXG4gICAgICAvLyByZXNldCB0aGUgc2NvcmUgYW5kIHNldCBwbGF5ZXIgdG8gYWxpdmVcclxuICAgICAgdGhpcy5TY29yZUN1ciA9IDA7XHJcbiAgICAgIHRoaXMuSXNBbGl2ZSA9IHRydWU7XHJcbiAgICB9LFxyXG4gICAgLy8gdXBkYXRlcyB0aW1lIGVhY2ggZnJhbWUgYW5kIGV4ZWN1dGluZyBsb2dpYyBpZiBhIHRpY2sgaGFzIHBhc3NlZFxyXG4gICAgVXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuVGltZUN1ciA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICBpZiAodGhpcy5UaW1lQ3VyID49IHRoaXMuVGltZUV2ZW50KSB7XHJcbiAgICAgICAgaWYgKEdNLlBjLkN1ciA9PT0gMCAmJiB0aGlzLklzQWxpdmUpIHtcclxuICAgICAgICAgIHRoaXMuUGMuR2VuZXJhdGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5QYy5Eb0dyYXZpdHkoKTtcclxuICAgICAgICAgIHRoaXMuUGMuUHJvalkgPSB0aGlzLlBjLlRyeVByb2plY3QoKTtcclxuICAgICAgICAgIFBhZ2UuR2FtZS5Jc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5SZWZyZXNoVGltZXIoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIHJlc2V0IHRoZSB0aWNrIHRpbWVyIChnZW5lcmF0ZXMgYSBuZXcgVGltZUV2ZW50IHRhcmdldClcclxuICAgIFJlZnJlc2hUaW1lcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLlRpbWVFdmVudCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5UaWNrUmF0ZTtcclxuICAgIH0sXHJcbiAgICAvLyBjYWxsZWQgd2hlbiBhIHBpZWNlIGlzIHNwYXduZWQsIGFkdmFuY2VzIGxldmVsIGlmIG5lZWRlZFxyXG4gICAgUGllY2VTcGF3bmVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuUGllY2VzUmVtYWluaW5nLS07XHJcbiAgICAgIGlmICh0aGlzLlBpZWNlc1JlbWFpbmluZyA8PSAwKSB7XHJcbiAgICAgICAgdGhpcy5BZHZhbmNlTGV2ZWwoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIGFkdmFuY2UgbGV2ZWwsIHJlY2FsY3VsYXRlIFRpY2tSYXRlLCByZXNldCBwaWVjZXMgcmVtYWluaW5nXHJcbiAgICBBZHZhbmNlTGV2ZWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5MZXZlbCsrO1xyXG4gICAgICB0aGlzLlRpY2tSYXRlID0gTWF0aC5mbG9vcig1NTUgKiBNYXRoLmV4cCh0aGlzLkxldmVsIC8gLTEwKSk7XHJcbiAgICAgIHRoaXMuUGllY2VzUmVtYWluaW5nID0gTWF0aC5mbG9vcig1MDAwIC8gdGhpcy5UaWNrUmF0ZSk7XHJcbiAgICAgIFBhZ2UuU2NvcmVCYXJDdXIuSXNEaXJ0eSA9IHRydWU7XHJcbiAgICB9LFxyXG4gICAgLy8gY2hlY2sgc3BlY2lmaWVkIHJvd3MgdG8gc2VlIGlmIGFueSBjYW4gYmUgY2xlYXJlZFxyXG4gICAgQ2hlY2tVbml0czogZnVuY3Rpb24gKGNoZWNrUm93c1Jhdykge1xyXG4gICAgICB2YXIgc2NvcmVNdWx0ID0gMCxcclxuICAgICAgICBwaWVjZVNjb3JlID0gMCxcclxuICAgICAgICBjaGVja1Jvd3MgPSBbXTtcclxuICBcclxuICAgICAgLy8gYWRkIHRoZSBzY29yZUJvbnVzIGZvciBkcm9wcGluZ1xyXG4gICAgICBpZiAodGhpcy5TY29yZUJvbnVzID4gMCkge1xyXG4gICAgICAgIHBpZWNlU2NvcmUgKz0gdGhpcy5TY29yZUJvbnVzO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIHNvcnQgdGhlIHJvd3NcclxuICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCAyMDsgYSsrKSB7XHJcbiAgICAgICAgaWYgKGNoZWNrUm93c1Jhdy5pbmRleE9mKGEpID49IDApIHtcclxuICAgICAgICAgIGNoZWNrUm93cy5wdXNoKGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrUm93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBoYXNHYXAgPSBmYWxzZSxcclxuICAgICAgICAgIGNoZWNrSW5kZXggPSBjaGVja1Jvd3NbaV07XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBHTS5TdGF0aWNVbml0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgaWYgKEdNLlN0YXRpY1VuaXRzW2pdW2NoZWNrSW5kZXhdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGhhc0dhcCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzR2FwID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBHTS5TdGF0aWNVbml0cy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICBHTS5TdGF0aWNVbml0c1trXS5zcGxpY2UoY2hlY2tJbmRleCwgMSk7XHJcbiAgICAgICAgICAgIEdNLlN0YXRpY1VuaXRzW2tdLnVuc2hpZnQoMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwaWVjZVNjb3JlICs9IDEwMCArIDIwMCAqIHNjb3JlTXVsdDtcclxuICAgICAgICAgIGlmIChzY29yZU11bHQgPiAyKSB7XHJcbiAgICAgICAgICAgIHBpZWNlU2NvcmUgKz0gMTAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2NvcmVNdWx0Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLkRpZmZpY3VsdEZsYWcgPT09IDEpIHtcclxuICAgICAgICBwaWVjZVNjb3JlID0gTWF0aC5mbG9vcihwaWVjZVNjb3JlICogMS41KTtcclxuICAgICAgICB0aGlzLkRpZmZpY3VsdEZsYWcgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwaWVjZVNjb3JlID4gMCkge1xyXG4gICAgICAgIHRoaXMuU2NvcmVDdXIgKz0gcGllY2VTY29yZTtcclxuICAgICAgICBQYWdlLlNjb3JlQmFyQ3VyLklzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuU2NvcmVCb251cyA9IDA7XHJcbiAgICAgICAgaWYgKHNjb3JlTXVsdCA+IDMpIHtcclxuICAgICAgICAgIHRoaXMuRGlmZmljdWx0RmxhZyA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgR2FtZU92ZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgUGFnZS5HYW1lLklzRGlydHkgPSBQYWdlLlNjb3JlQmFyQ3VyLklzRGlydHkgPSB0cnVlO1xyXG4gICAgICBpZiAodGhpcy5TY29yZUN1ciA+IHRoaXMuU2NvcmVIaWdoKSB7XHJcbiAgICAgICAgdGhpcy5TY29yZUhpZ2ggPSB0aGlzLlNjb3JlQ3VyO1xyXG4gICAgICAgIFBhZ2UuU2NvcmVCYXJIaWdoLklzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuU2NvcmVIaWdoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLklzQWxpdmUgPSBmYWxzZTtcclxuICAgIH1cclxuICB9O1xyXG4gIFxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIC8vICAgIFBJRUNFIE9CSkVDVCBCVUlMREVSICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIFxyXG4gIC8vIFBjT2JqIGlzIHVzZWQgdG8gY3JlYXRlIG5ldyBwaWVjZSBvYmplY3QgaW5zdGFuY2VzIGJhc2VkIG9uIHRoZVxyXG4gIC8vIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLiBQY09iaiBpcyBjYWxsZWQgYnkgcHJlZGVmaW5lZCB0ZW1wbGF0ZXNcclxuICBcclxuICBHTS5QY09iaiA9IGZ1bmN0aW9uIChjb2xvciwgcm90Q291bnQsIHVuaXRzKSB7XHJcbiAgICB0aGlzLnggPSA1O1xyXG4gICAgdGhpcy55ID0gMDtcclxuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgIHRoaXMuVU8gPSB7fTtcclxuICBcclxuICAgIC8vIHJvdGF0ZSB0aGlzIHBpZWNlIGJ5IGFkdmFuY2luZyB0byBuZXh0IHVuaXQgb2JqIG9mIGxpbmtlZCBsaXN0XHJcbiAgICB0aGlzLlJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5VTyA9IHRoaXMuVU8ubmV4dFVPO1xyXG4gICAgfTtcclxuICBcclxuICAgIC8vIHNldCB1cCB0aGUgcGllY2UgdW5pdCBvYmplY3QgbGlua2VkIGxpc3QgdG8gZGVmaW5lIHJvdGF0aW9uc1xyXG4gICAgdGhpcy5TZXRVTyA9IGZ1bmN0aW9uIChyb3RDb3VudCwgdW5pdHMpIHtcclxuICAgICAgdmFyIGxpbmtlZExpc3RVTyA9IFtdO1xyXG4gICAgICBsaW5rZWRMaXN0VU9bMF0gPSB7XHJcbiAgICAgICAgbmV4dFVPOiAwLFxyXG4gICAgICAgIGFycjogW11cclxuICAgICAgfTtcclxuICAgICAgbGlua2VkTGlzdFVPWzBdLmFyciA9IHVuaXRzO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdENvdW50OyBpKyspIHtcclxuICAgICAgICB2YXIgbmV4dEkgPSBpICsgMSA8IHJvdENvdW50ID8gaSArIDEgOiAwO1xyXG4gICAgICAgIGxpbmtlZExpc3RVT1tpXSA9IHtcclxuICAgICAgICAgIG5leHRVTzogMCxcclxuICAgICAgICAgIGFycjogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgbGlua2VkTGlzdFVPW2kgLSAxXS5uZXh0VU8gPSBsaW5rZWRMaXN0VU9baV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdW5pdHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIHZhciB1blgsIHVuWTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHVuWCA9IHVuaXRzW2pdLng7XHJcbiAgICAgICAgICAgIHVuWSA9IHVuaXRzW2pdLnk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB1blggPSBsaW5rZWRMaXN0VU9baSAtIDFdLmFycltqXS55ICogLTE7XHJcbiAgICAgICAgICAgIHVuWSA9IGxpbmtlZExpc3RVT1tpIC0gMV0uYXJyW2pdLng7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsaW5rZWRMaXN0VU9baV0uYXJyW2pdID0ge1xyXG4gICAgICAgICAgICB4OiB1blgsXHJcbiAgICAgICAgICAgIHk6IHVuWVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbGlua2VkTGlzdFVPW3JvdENvdW50IC0gMV0ubmV4dFVPID0gbGlua2VkTGlzdFVPWzBdO1xyXG4gICAgICB0aGlzLlVPID0gbGlua2VkTGlzdFVPWzBdO1xyXG4gICAgfTtcclxuICAgIHRoaXMuU2V0VU8ocm90Q291bnQsIHVuaXRzKTtcclxuICB9O1xyXG4gIFxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIC8vICAgIFBJRUNFIFRZUEUgVEVNUExBVEVTICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIFxyXG4gIC8vIFRlbXBsYXRlcyBjcmVhdGUgYSBuZXcgcGllY2Ugb2JqZWN0IGluc3RhbmNlIGJhc2VkIG9uXHJcbiAgLy8gdGhlaXIgY29sb3IsIHJvdGF0aW9uIGNvdW50LCBhbmQgdW5pdCBibG9jayBkZWZpbml0aW9ucy5cclxuICBcclxuICAvLyBPIC0gU3F1YXJlIHBpZWNlIGRlZmluaXRpb25cclxuICBHTS5PID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBHTS5QY09iaigncmdiKDI1NSwyMzIsNTEpJywgMSwgW3tcclxuICAgICAgeDogLTEsXHJcbiAgICAgIHk6IDBcclxuICAgIH0sIHtcclxuICAgICAgeDogMCxcclxuICAgICAgeTogMFxyXG4gICAgfSwge1xyXG4gICAgICB4OiAtMSxcclxuICAgICAgeTogMVxyXG4gICAgfSwge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAxXHJcbiAgICB9XSk7XHJcbiAgfTtcclxuICBcclxuICAvLyBJIC0gTGluZSBwaWVjZSBkZWZpbml0aW9uXHJcbiAgR00uSSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgR00uUGNPYmooJ3JnYig1MSwyNTUsMjA5KScsIDIsIFt7XHJcbiAgICAgIHg6IC0yLFxyXG4gICAgICB5OiAwXHJcbiAgICB9LCB7XHJcbiAgICAgIHg6IC0xLFxyXG4gICAgICB5OiAwXHJcbiAgICB9LCB7XHJcbiAgICAgIHg6IDAsXHJcbiAgICAgIHk6IDBcclxuICAgIH0sIHtcclxuICAgICAgeDogMSxcclxuICAgICAgeTogMFxyXG4gICAgfV0pO1xyXG4gIH07XHJcbiAgXHJcbiAgLy8gUyAtIFJpZ2h0IGZhY2luZyB6aWd6YWcgcGllY2UgZGVmaW5pdGlvblxyXG4gIEdNLlMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbmV3IEdNLlBjT2JqKCdyZ2IoMTA2LDI1NSw1MSknLCAyLCBbe1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAwXHJcbiAgICB9LCB7XHJcbiAgICAgIHg6IDEsXHJcbiAgICAgIHk6IDBcclxuICAgIH0sIHtcclxuICAgICAgeDogLTEsXHJcbiAgICAgIHk6IDFcclxuICAgIH0sIHtcclxuICAgICAgeDogMCxcclxuICAgICAgeTogMVxyXG4gICAgfV0pO1xyXG4gIH07XHJcbiAgXHJcbiAgLy8gWiAtIExlZnQgZmFjaW5nIHppZ3phZyBwaWVjZSBkZWZpbml0aW9uXHJcbiAgR00uWiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuZXcgR00uUGNPYmooJ3JnYigyNTUsNTEsODMpJywgMiwgW3tcclxuICAgICAgeDogLTEsXHJcbiAgICAgIHk6IDBcclxuICAgIH0sIHtcclxuICAgICAgeDogMCxcclxuICAgICAgeTogMFxyXG4gICAgfSwge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAxXHJcbiAgICB9LCB7XHJcbiAgICAgIHg6IDEsXHJcbiAgICAgIHk6IDFcclxuICAgIH1dKTtcclxuICB9O1xyXG4gIFxyXG4gIC8vIEwgLSBSaWdodCBmYWNpbmcgYW5nbGUgcGllY2UgZGVmaW5pdGlvblxyXG4gIEdNLkwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbmV3IEdNLlBjT2JqKCdyZ2IoMjU1LDEyOSw1MSknLCA0LCBbe1xyXG4gICAgICB4OiAtMSxcclxuICAgICAgeTogMFxyXG4gICAgfSwge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAwXHJcbiAgICB9LCB7XHJcbiAgICAgIHg6IDEsXHJcbiAgICAgIHk6IDBcclxuICAgIH0sIHtcclxuICAgICAgeDogLTEsXHJcbiAgICAgIHk6IC0xXHJcbiAgICB9XSk7XHJcbiAgfTtcclxuICBcclxuICAvLyBKIC0gTGVmdCBmYWNpbmcgYW5nbGUgcGllY2UgZGVmaW5pdGlvblxyXG4gIEdNLkogPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbmV3IEdNLlBjT2JqKCdyZ2IoNjQsMTAwLDI1NSknLCA0LCBbe1xyXG4gICAgICB4OiAtMSxcclxuICAgICAgeTogMFxyXG4gICAgfSwge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAwXHJcbiAgICB9LCB7XHJcbiAgICAgIHg6IDEsXHJcbiAgICAgIHk6IDBcclxuICAgIH0sIHtcclxuICAgICAgeDogMSxcclxuICAgICAgeTogLTFcclxuICAgIH1dKTtcclxuICB9O1xyXG4gIFxyXG4gIC8vIFQgLSBIYXQgc2hhcGVkIHBpZWNlIGRlZmluaXRpb25cclxuICBHTS5UID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBHTS5QY09iaigncmdiKDE2MCw2MiwyNTUpJywgNCwgW3tcclxuICAgICAgeDogLTEsXHJcbiAgICAgIHk6IDBcclxuICAgIH0sIHtcclxuICAgICAgeDogMCxcclxuICAgICAgeTogMFxyXG4gICAgfSwge1xyXG4gICAgICB4OiAxLFxyXG4gICAgICB5OiAwXHJcbiAgICB9LCB7XHJcbiAgICAgIHg6IDAsXHJcbiAgICAgIHk6IC0xXHJcbiAgICB9XSk7XHJcbiAgfTtcclxuICBcclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cclxuICAvLyAgICBBQ1RJVkUgUElFQ0UgQ09OVFJPTExFUiAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cclxuICBcclxuICAvLyBDb250cm9scyB0aGUgZ2VuZXJhdGlvbiwgbW92ZW1lbnQsIGFuZCBwbGFjZW1lbnQgb2YgcGllY2UgXHJcbiAgLy8gb2JqZWN0cy4gTW9uaXRvcnMgdGhlIGN1cnJlbnQgcGllY2UgYW5kIHVwY29taW5nIHBpZWNlXHJcbiAgXHJcbiAgR00uUGMgPSB7XHJcbiAgICAvLy0tIFZBUlMgLS0tLS0tLS0tKi9cclxuICBcclxuICAgIC8vIGN1cnJlbnQgcGllY2UsIHByb2plY3RlZCBZIHBvcyBvZiBjdXIgcGllY2UgIFxyXG4gICAgQ3VyOiAwLFxyXG4gICAgUHJvalk6IDAsXHJcbiAgICAvLyB1cGNvbWluZyBwaWVjZXNcclxuICAgIFVwY29taW5nOiBbMCwgMCwgMF0sXHJcbiAgICAvLy0tIEZDTlMgLS0tLS0tLS0tKi9cclxuICBcclxuICAgIC8vIHB1c2ggdXBjb21pbmcgcGllY2UgdG8gY3VycmVudCAmIHJhbmRvbWl6ZSBuZXcgdXBjb21pbmcgcGllY2VcclxuICAgIEdlbmVyYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIC8vIHB1c2ggdXBjb21pbmcgcGllY2UgdG8gY3VycmVudCBhbmQgcHVzaCBkb3duIG90aGVyIHVwY29taW5nc1xyXG4gICAgICB0aGlzLkN1ciA9IHRoaXMuVXBjb21pbmdbMF07XHJcbiAgICAgIHRoaXMuVXBjb21pbmdbMF0gPSB0aGlzLlVwY29taW5nWzFdO1xyXG4gICAgICB0aGlzLlVwY29taW5nWzFdID0gdGhpcy5VcGNvbWluZ1syXTtcclxuICBcclxuICAgICAgLy8gY2hlY2sgaWYgdGhlIHBsYXllciBsb3N0XHJcbiAgICAgIGlmICh0aGlzLkN1ciAhPT0gMCkge1xyXG4gICAgICAgIHZhciBzcGF3bkNvbGxpc2lvbnMgPSB0aGlzLkNoZWNrQ29sbGlzaW9ucygwLCAwLCAwKTtcclxuICAgICAgICBpZiAoc3Bhd25Db2xsaXNpb25zID4gMCkge1xyXG4gICAgICAgICAgR00uR2FtZU92ZXIoKTtcclxuICAgICAgICAgIHRoaXMuRnJlZXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8vIGlmIHBsYXllciBpcyBhbGl2ZSwgZ2VuZXJhdGUgcmFuZG9tIHVwY29taW5nIHBpZWNlXHJcbiAgICAgIGlmIChHTS5Jc0FsaXZlICE9PSAwKSB7XHJcbiAgICAgICAgdmFyIHJhbmRJbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA3KTtcclxuICAgICAgICBzd2l0Y2ggKHJhbmRJbnQpIHtcclxuICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgdGhpcy5VcGNvbWluZ1syXSA9IEdNLk8oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuVXBjb21pbmdbMl0gPSBHTS5JKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICB0aGlzLlVwY29taW5nWzJdID0gR00uUygpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdGhpcy5VcGNvbWluZ1syXSA9IEdNLlooKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHRoaXMuVXBjb21pbmdbMl0gPSBHTS5MKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICB0aGlzLlVwY29taW5nWzJdID0gR00uSigpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgdGhpcy5VcGNvbWluZ1syXSA9IEdNLlQoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgLy8gaWYgYSBjdXJyZW50IHBpZWNlIHdhcyBzZXQsIGluZm9ybSB0aGUgR01cclxuICAgICAgICBpZiAodGhpcy5DdXIgIT09IDApIHtcclxuICAgICAgICAgIEdNLlBpZWNlU3Bhd25lZCgpO1xyXG4gICAgICAgICAgUGFnZS5HYW1lLklzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQYWdlLlVwY29taW5nQS5Jc0RpcnR5ID0gUGFnZS5VcGNvbWluZ0IuSXNEaXJ0eSA9IFBhZ2UuVXBjb21pbmdDLklzRGlydHkgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gZnJlZXplIHRoZSBjdXJyZW50IHBpZWNlJ3MgcG9zaXRpb24gYW5kIHJvdGF0aW9uXHJcbiAgICBGcmVlemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKEdNLklzQWxpdmUpIHtcclxuICAgICAgICB2YXIgYWZmZWN0ZWRSb3dzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLkN1ci5VTy5hcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciBzdGF0aWNYID0gdGhpcy5DdXIueCArIHRoaXMuQ3VyLlVPLmFycltpXS54LFxyXG4gICAgICAgICAgICBzdGF0aWNZID0gdGhpcy5DdXIueSArIHRoaXMuQ3VyLlVPLmFycltpXS55O1xyXG4gICAgICAgICAgaWYgKHN0YXRpY1kgPj0gMCAmJiBzdGF0aWNZIDw9IEdNLlN0YXRpY1VuaXRzWzBdLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBHTS5TdGF0aWNVbml0c1tzdGF0aWNYXVtzdGF0aWNZXSA9IHRoaXMuQ3VyLmNvbG9yO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGFmZmVjdGVkUm93cy5pbmRleE9mKHN0YXRpY1kpIDwgMCkge1xyXG4gICAgICAgICAgICBhZmZlY3RlZFJvd3MucHVzaChzdGF0aWNZKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgR00uQ2hlY2tVbml0cyhhZmZlY3RlZFJvd3MpO1xyXG4gICAgICAgIHRoaXMuR2VuZXJhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIGFwcGx5IGdyYXZpdHkgdG8gdGhlIGN1cnJlbnQgcGllY2UsIGNoZWNraW5nIGZvciBjb2xsaXNpb25zXHJcbiAgICBEb0dyYXZpdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMuQ3VyICE9PSAwKSB7XHJcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSB0aGlzLkNoZWNrQ29sbGlzaW9ucygwLCAwLCAxKTtcclxuICAgICAgICBpZiAoY29sbGlzaW9ucyA9PT0gMCkge1xyXG4gICAgICAgICAgdGhpcy5DdXIueSsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLkZyZWV6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBHTS5SZWZyZXNoVGltZXIoKTtcclxuICAgIH0sXHJcbiAgICAvLyBhdHRlbXB0IHRvIHJvdGF0ZSB0aGUgY3VycmVudCBwaWVjZSwgcmV0dXJucyBib29sXHJcbiAgICBUcnlSb3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMuQ3VyICE9PSAwKSB7XHJcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSB0aGlzLkNoZWNrQ29sbGlzaW9ucygxLCAwLCAwKTtcclxuICAgICAgICBpZiAoY29sbGlzaW9ucyA9PT0gMCkge1xyXG4gICAgICAgICAgdGhpcy5DdXIuUm90YXRlKCk7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIC8vIGF0dGVtcHQgdG8gbW92ZSBjdXJyZW50IHBpZWNlIGJhc2Ugb24gZ2l2ZW4gWFksIHJldHVybnMgYm9vbFxyXG4gICAgVHJ5TW92ZTogZnVuY3Rpb24gKG1vdmVYLCBtb3ZlWSkge1xyXG4gICAgICBpZiAodGhpcy5DdXIgIT09IDApIHtcclxuICAgICAgICB2YXIgY29sbGlzaW9ucyA9IHRoaXMuQ2hlY2tDb2xsaXNpb25zKDAsIG1vdmVYLCBtb3ZlWSk7XHJcbiAgICAgICAgaWYgKGNvbGxpc2lvbnMgPT09IDApIHtcclxuICAgICAgICAgIHRoaXMuQ3VyLnggKz0gbW92ZVg7XHJcbiAgICAgICAgICB0aGlzLkN1ci55ICs9IG1vdmVZO1xyXG4gICAgICAgICAgaWYgKG1vdmVZID4gMCkge1xyXG4gICAgICAgICAgICBHTS5SZWZyZXNoVGltZXIoKTtcclxuICAgICAgICAgICAgR00uU2NvcmVCb251cysrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICAvLyBhdHRlbXB0IHRvIGRyb3AgdGhlIGN1cnJlbnQgcGllY2UgdW50aWwgaXQgY29sbGlkZXMsIHJldHVybnMgYm9vbFxyXG4gICAgVHJ5RHJvcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc3F1YXJlc0Ryb3BwZWQgPSAwO1xyXG4gICAgICBpZiAodGhpcy5DdXIgIT09IDApIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5UcnlNb3ZlKDAsIDEpID09PSB0cnVlICYmIHNxdWFyZXNEcm9wcGVkIDwgMjIpIHtcclxuICAgICAgICAgIHNxdWFyZXNEcm9wcGVkKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzcXVhcmVzRHJvcHBlZCA+IDApIHtcclxuICAgICAgICBHTS5TY29yZUJvbnVzICs9IDIgKiBzcXVhcmVzRHJvcHBlZDtcclxuICAgICAgICB0aGlzLkZyZWV6ZSgpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIGF0dGVtcHQgdG8gZmluZCAoYW5kIHJldHVybikgcHJvamVjdGVkIGRyb3AgcG9pbnQgb2YgY3VycmVudCBwaWVjZVxyXG4gICAgVHJ5UHJvamVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc3F1YXJlc0Ryb3BwZWQgPSAwO1xyXG4gICAgICBpZiAodGhpcy5DdXIgIT09IDApIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5DaGVja0NvbGxpc2lvbnMoMCwgMCwgc3F1YXJlc0Ryb3BwZWQpID09PSAwICYmIHNxdWFyZXNEcm9wcGVkIDwgMjIpIHtcclxuICAgICAgICAgIHNxdWFyZXNEcm9wcGVkKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzcXVhcmVzRHJvcHBlZCAtIDE7XHJcbiAgICB9LFxyXG4gICAgLy8gcmV0dXJuIGNvbGxpc2lvbiBjb3VudCBPUiAtMSBpZiB0ZXN0IHBpZWNlIG91dCBvZiBib3VuZHNcclxuICAgIENoZWNrQ29sbGlzaW9uczogZnVuY3Rpb24gKGRvUm90LCBvZmZzZXRYLCBvZmZzZXRZKSB7XHJcbiAgICAgIHZhciB1bml0QXJyLFxyXG4gICAgICAgIGNvbGxpc2lvbkNvdW50ID0gMDtcclxuICAgICAgaWYgKGRvUm90ID09PSAxKSB7XHJcbiAgICAgICAgdW5pdEFyciA9IHRoaXMuQ3VyLlVPLm5leHRVTy5hcnI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5pdEFyciA9IHRoaXMuQ3VyLlVPLmFycjtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaXRBcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgdGVzdFggPSB0aGlzLkN1ci54ICsgdW5pdEFycltpXS54ICsgb2Zmc2V0WCxcclxuICAgICAgICAgIHRlc3RZID0gdGhpcy5DdXIueSArIHVuaXRBcnJbaV0ueSArIG9mZnNldFksXHJcbiAgICAgICAgICBsaW1pdFggPSBHTS5TdGF0aWNVbml0cy5sZW5ndGgsXHJcbiAgICAgICAgICBsaW1pdFkgPSBHTS5TdGF0aWNVbml0c1swXS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRlc3RYIDwgMCB8fCB0ZXN0WCA+PSBsaW1pdFggfHwgdGVzdFkgPj0gbGltaXRZKSB7XHJcbiAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0WSA+IDApIHtcclxuICAgICAgICAgIGlmIChHTS5TdGF0aWNVbml0c1t0ZXN0WF1bdGVzdFldICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkNvdW50Kys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb2xsaXNpb25Db3VudDtcclxuICAgIH1cclxuICB9O1xyXG4gIFxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIC8vICAgIEVWRU5UIExJU1RFTkVSUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIFxyXG4gIC8vIEV2ZW50IGZvciBrZXlib2FyZCBjYWxscyB0aGUgY29ycmVzcG9uZGluZyBtYW5pcHVsYXRpb24gZnVuY3Rpb25zXHJcbiAgLy8gaW4gR00uUGMgYmFzZWQgb24gdXNlciBpbnB1dHMuIElmIG1hbmlwdWxhdGlvbiBpcyBzdWNjZXNzZnVsLFxyXG4gIC8vIHRoZSBwYWdlIGlzIG1hcmtlZCBhcyBkaXJ0eS5cclxuICBcclxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgdmFyIGtleSA9IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQud2hpY2g7XHJcbiAgICBpZiAoR00uSXNBbGl2ZSkge1xyXG4gICAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIC8vIFVwIGFycm93IE9SIFcgPSByb3RhdGUgICAgIFxyXG4gICAgICAgIGNhc2UgMzg6XHJcbiAgICAgICAgY2FzZSA4NzpcclxuICAgICAgICAgIFBhZ2UuR2FtZS5Jc0RpcnR5ID0gR00uUGMuVHJ5Um90YXRlKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICBcclxuICAgICAgICAvLyBMZWZ0IGFycm93IE9SIEEgPSBtb3ZlIGxlZnRcclxuICAgICAgICBjYXNlIDM3OlxyXG4gICAgICAgIGNhc2UgNjU6XHJcbiAgICAgICAgICBQYWdlLkdhbWUuSXNEaXJ0eSA9IEdNLlBjLlRyeU1vdmUoLTEsIDApO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgXHJcbiAgICAgICAgLy8gUmlnaHQgYXJyb3cgT1IgRCA9IG1vdmUgcmlnaHQgIFxyXG4gICAgICAgIGNhc2UgMzk6XHJcbiAgICAgICAgY2FzZSA2ODpcclxuICAgICAgICAgIFBhZ2UuR2FtZS5Jc0RpcnR5ID0gR00uUGMuVHJ5TW92ZSgxLCAwKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gIFxyXG4gICAgICAgIC8vIERvd24gYXJyb3cgT1IgUyA9IG1vdmUgZG93biAgXHJcbiAgICAgICAgY2FzZSA0MDpcclxuICAgICAgICBjYXNlIDgzOlxyXG4gICAgICAgICAgUGFnZS5HYW1lLklzRGlydHkgPSBHTS5QYy5UcnlNb3ZlKDAsIDEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgXHJcbiAgICAgICAgLy8gU3BhY2ViYXIgdG8gZHJvcCB0aGUgY3VycmVudCBwaWVjZVxyXG4gICAgICAgIGNhc2UgMzI6XHJcbiAgICAgICAgICBQYWdlLkdhbWUuSXNEaXJ0eSA9IEdNLlBjLlRyeURyb3AoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvL2lmIGJvYXJkIHdhcyBkaXJ0aWVkLCBjYXN0IGZyZXNoIHByb2plY3Rpb24gZm9yIGN1cnJlbnQgcGllY2VcclxuICAgICAgaWYgKFBhZ2UuR2FtZS5Jc0RpcnR5KSB7XHJcbiAgICAgICAgR00uUGMuUHJvalkgPSBHTS5QYy5UcnlQcm9qZWN0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIC8vIGlmIHBsYXllciBub3QgYWxpdmUsIHJlc2V0IHRoZSBnYW1lXHJcbiAgICBlbHNlIHtcclxuICAgICAgSW5pdCgpO1xyXG4gICAgfVxyXG4gIH0sIGZhbHNlKTtcclxuICBcclxuICAvLyBXaW5kb3cgcmVzaXplIGV2ZW50IGNhbGxzIFBhZ2UgZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSBjYW52YXMgXHJcbiAgLy8gc2l6ZS9wb3NpdGlvbiwgYXJlYSBib3VuZHMgd2l0aGluIHRoZSBjYW52YXMsIGFuZCB0aGUgdW5pdFNpemVcclxuICBcclxuICB3aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIFBhZ2UuV2luZG93Q2hhbmdlZCgpO1xyXG4gIH07XHJcbiAgXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXHJcbiAgLy8gICAgSU5JVElBTEFaQVRJT04gQU5EIEdBTUUgTE9PUCAgICAgICAgICAgICAgICAgIC8vXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXHJcbiAgXHJcbiAgLy8gQ2FsbGVkIG9uIHBhZ2UgbG9hZCAvIGdhbWUgcmVzZXQsIEluaXQgZmNuIGluaXRpYWxpemVzIFxyXG4gIC8vIHRoZSBQYWdlIGFuZCBHTSBvYmplY3RzLCB0aGVuIHN0YXJ0cyB0aGUgbWFpbiBnYW1lIGxvb3AuXHJcbiAgXHJcbiAgZnVuY3Rpb24gSW5pdCgpIHtcclxuICAgIC8vIGluaXRpYWxpemUgdGhlIHBhZ2Ugb2JqZWN0XHJcbiAgICBQYWdlLkluaXRpYWxpemUoKTtcclxuICBcclxuICAgIC8vIGluaXRpYWxpemUgdGhlIEdNIG9iamVjdFxyXG4gICAgR00uSW5pdGlhbGl6ZSgpO1xyXG4gIH1cclxuICBJbml0KCk7XHJcbiAgXHJcbiAgLy8gTWFpbiBnYW1lIGxvb3AuIFVwZGF0ZXMgR00gb2JqZWN0IHRvIGNoZWNrIGlmIHRpY2sgY2FuIGJlXHJcbiAgLy8gcGVyZm9ybWVkLiBUaGVuLCBpZiB0aGUgcGFnZSBpcyBkaXJ0eSwgcGVyZm9ybXMgYSBEcmF3LlxyXG4gIFxyXG4gIGZ1bmN0aW9uIExvb3AoKSB7XHJcbiAgICAvLyBhbHdheXMgdXBkYXRlIFBhZ2VcclxuICAgIFBhZ2UuVXBkYXRlKCk7XHJcbiAgXHJcbiAgICAvLyBvbmx5IG5lZWQgdG8gdXBkYXRlIEdNIGlmIHRoZSBwbGF5ZXIgaXMgYWxpdmVcclxuICAgIGlmIChHTS5Jc0FsaXZlKSB7XHJcbiAgICAgIEdNLlVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShMb29wKTtcclxuICB9XHJcbiAgTG9vcCgpO1xyXG4gIFxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIC8vICAgIEhFTFBFUiBGVU5DVElPTlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xyXG4gIFxyXG4gIGZ1bmN0aW9uIERyYXdUZXh0KHRleHQsIGNvbG9yLCB3ZWlnaHQsIGFsaWdubWVudCwgc2l6ZSwgbGVmdCwgdG9wKSB7XHJcbiAgICBQYWdlLmN0eC5mb250ID0gd2VpZ2h0ICsgJyAnICsgc2l6ZSArICdweCBcIkp1cmFcIiwgc2Fucy1zZXJpZic7XHJcbiAgICBQYWdlLmN0eC50ZXh0QWxpZ24gPSBhbGlnbm1lbnQ7XHJcbiAgICBQYWdlLmN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgIFBhZ2UuY3R4LmZpbGxUZXh0KHRleHQsIGxlZnQsIHRvcCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIENvbG9yV2l0aEFscGhhKGNvbG9yLCBhbHBoYSkge1xyXG4gICAgdmFyIHJldENvbG9yID0gJ3JnYmEnICsgY29sb3Iuc3Vic3RyaW5nKDMsIGNvbG9yLmxlbmd0aCAtIDEpO1xyXG4gICAgcmV0Q29sb3IgKz0gJywnICsgYWxwaGEgKyAnKSc7XHJcbiAgICByZXR1cm4gcmV0Q29sb3I7XHJcbiAgfSJdLCJuYW1lcyI6WyJQYWdlIiwiSXNTZXR1cCIsImJvZHkiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiY3ZzIiwiY3JlYXRlRWxlbWVudCIsImN0eCIsInVuaXRTaXplIiwiQXJlYUFyciIsIldpbmRvd0NoYW5nZWQiLCJib2R5VyIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwiYm9keUgiLCJjbGllbnRIZWlnaHQiLCJuZXdVbml0VyIsIm5ld1VuaXRIIiwibmV3VW5pdE1pbiIsIk1hdGgiLCJtYXgiLCJtaW4iLCJyaWdodExpbWl0IiwiYm90dG9tTGltaXQiLCJpIiwibGVuZ3RoIiwiQ2FsY3VsYXRlQm91bmRzIiwibmV3UmlnaHRMaW1pdCIsImxlZnQiLCJXIiwibmV3Qm90dG9tTGltaXQiLCJ0b3AiLCJIIiwid2lkdGgiLCJoZWlnaHQiLCJ0b3BQb3MiLCJsZWZ0UG9zIiwiR2FtZSIsInJpZ2h0T2Zmc2V0Iiwic3R5bGUiLCJJbml0aWFsaXplIiwiYXBwZW5kQ2hpbGQiLCJvdmVyZmxvdyIsImJhY2tncm91bmRDb2xvciIsInBvc2l0aW9uIiwiZ2V0Q29udGV4dCIsIklzRGlydHkiLCJVcGRhdGUiLCJEcmF3IiwiRHJhd0FyZWFPYmoiLCJMZWZ0IiwiVG9wIiwiV2lkdGgiLCJIZWlnaHQiLCJEcmF3RnVuY3Rpb24iLCJsZWZ0QmFzZSIsInRvcEJhc2UiLCJ3aWR0aEJhc2UiLCJoZWlnaHRCYXNlIiwicHVzaCIsInVEcmF3U2l6ZSIsImRyYXdMIiwiZHJhd1QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsIkdNIiwiU3RhdGljVW5pdHMiLCJqIiwidVZhbHVlIiwiSXNBbGl2ZSIsIlBjIiwiQ3VyIiwicHJvakNvbG9yIiwiQ29sb3JXaXRoQWxwaGEiLCJjb2xvciIsImsiLCJVTyIsImFyciIsIngiLCJ5IiwiUHJvalkiLCJEcmF3VGV4dCIsIlVwY29taW5nQSIsImZsb29yIiwicGNBIiwiVXBjb21pbmciLCJ0b3RhbEwiLCJ0b3RhbFQiLCJjb3VudGVkTCIsImNvdW50ZWRUIiwiY3VyWCIsImN1clkiLCJpbmRleE9mIiwiYXZnTCIsImF2Z1QiLCJvZmZzZXRMIiwib2Zmc2V0VCIsImNvbnNvbGUiLCJsb2ciLCJVcGNvbWluZ0IiLCJwY0IiLCJVcGNvbWluZ0MiLCJwY0MiLCJTY29yZUJhckhpZ2giLCJtaW5pVW5pdCIsImFyYyIsIlBJIiwiZmlsbCIsInRleHQiLCJTY29yZUhpZ2giLCJzbGljZSIsInNpemUiLCJTY29yZUJhckN1ciIsIkxldmVsIiwiU2NvcmVDdXIiLCJUaW1lQ3VyIiwiVGltZUV2ZW50IiwiVGlja1JhdGUiLCJQaWVjZXNSZW1haW5pbmciLCJTY29yZUJvbnVzIiwiRGlmZmljdWx0RmxhZyIsIk5leHQiLCJEYXRlIiwiZ2V0VGltZSIsIkdlbmVyYXRlIiwiRG9HcmF2aXR5IiwiVHJ5UHJvamVjdCIsIlJlZnJlc2hUaW1lciIsIlBpZWNlU3Bhd25lZCIsIkFkdmFuY2VMZXZlbCIsImV4cCIsIkNoZWNrVW5pdHMiLCJjaGVja1Jvd3NSYXciLCJzY29yZU11bHQiLCJwaWVjZVNjb3JlIiwiY2hlY2tSb3dzIiwiYSIsImhhc0dhcCIsImNoZWNrSW5kZXgiLCJzcGxpY2UiLCJ1bnNoaWZ0IiwiR2FtZU92ZXIiLCJQY09iaiIsInJvdENvdW50IiwidW5pdHMiLCJSb3RhdGUiLCJuZXh0VU8iLCJTZXRVTyIsImxpbmtlZExpc3RVTyIsIm5leHRJIiwidW5YIiwidW5ZIiwiTyIsIkkiLCJTIiwiWiIsIkwiLCJKIiwiVCIsInNwYXduQ29sbGlzaW9ucyIsIkNoZWNrQ29sbGlzaW9ucyIsIkZyZWV6ZSIsInJhbmRJbnQiLCJyYW5kb20iLCJhZmZlY3RlZFJvd3MiLCJzdGF0aWNYIiwic3RhdGljWSIsImNvbGxpc2lvbnMiLCJUcnlSb3RhdGUiLCJUcnlNb3ZlIiwibW92ZVgiLCJtb3ZlWSIsIlRyeURyb3AiLCJzcXVhcmVzRHJvcHBlZCIsImRvUm90Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJ1bml0QXJyIiwiY29sbGlzaW9uQ291bnQiLCJ0ZXN0WCIsInRlc3RZIiwibGltaXRYIiwibGltaXRZIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2dCIsImtleSIsImV2ZW50Iiwia2V5Q29kZSIsIndoaWNoIiwiSW5pdCIsIndpbmRvdyIsIm9ucmVzaXplIiwiTG9vcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlaWdodCIsImFsaWdubWVudCIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsVGV4dCIsImFscGhhIiwicmV0Q29sb3IiLCJzdWJzdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/tetris/page.jsx\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5Cmelon%5CS4F-Projekt%5Cpages%5Ctetris%5Cpage.jsx&page=%2Ftetris%2Fpage!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);